<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.353">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Bauke Brenninkmeijer">
<meta name="dcterms.date" content="2023-02-16">
<meta name="description" content="How we can leverage genetic algorithms to help with image reconstruction.">

<title>Bauke Brenninkmeijer - Genetic Algorithms for image reconstruction 🧬</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../posts/images/favicon.png" rel="icon" type="image/png">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

<script type="text/javascript">

(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-55798897-4', 'auto');

ga('send', {
  hitType: 'pageview',
  'anonymizeIp': true,
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>
        <script type="text/javascript">
        window.PlotlyConfig = {MathJaxConfig: 'local'};
        if (window.MathJax && window.MathJax.Hub && window.MathJax.Hub.Config) {window.MathJax.Hub.Config({SVG: {font: "STIX-Web"}});}
        if (typeof require !== 'undefined') {
        require.undef("plotly");
        requirejs.config({
            paths: {
                'plotly': ['https://cdn.plot.ly/plotly-2.18.0.min']
            }
        });
        require(['plotly'], function(Plotly) {
            window._Plotly = Plotly;
        });
        }
        </script>
        

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../styles/styles.scss">
<meta property="og:title" content="Bauke Brenninkmeijer - Genetic Algorithms for image reconstruction 🧬">
<meta property="og:description" content="How we can leverage genetic algorithms to help with image reconstruction.">
<meta property="og:image" content="https://github.com/Baukebrenninkmeijer/blog/posts/images/genetic-algorithms/banner.png">
<meta property="og:site-name" content="Bauke Brenninkmeijer">
<meta property="og:image:height" content="662">
<meta property="og:image:width" content="1250">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Bauke Brenninkmeijer</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../talks.html" rel="" target="">
 <span class="menu-text">Talks</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html" rel="" target="">
 <span class="menu-text">Who am I?</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../resume.html" rel="" target="">
 <span class="menu-text">Resume</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/bauke-brenninkmeijer-40143310b/" rel="" target=""><i class="bi bi-linkedin" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.baukebrenninkmeijer.nl" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title">Genetic Algorithms for image reconstruction 🧬</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
                  <div>
        <div class="description">
          How we can leverage genetic algorithms to help with image reconstruction.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Genetic Algorithms</div>
                <div class="quarto-category">Machine learning</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Bauke Brenninkmeijer </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">February 16, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a>
  <ul class="collapse">
  <li><a href="#the-algorithm" id="toc-the-algorithm" class="nav-link" data-scroll-target="#the-algorithm">The algorithm</a></li>
  <li><a href="#mutations" id="toc-mutations" class="nav-link" data-scroll-target="#mutations">Mutations</a></li>
  <li><a href="#procreation" id="toc-procreation" class="nav-link" data-scroll-target="#procreation">Procreation</a></li>
  <li><a href="#fitness-function" id="toc-fitness-function" class="nav-link" data-scroll-target="#fitness-function">Fitness function</a></li>
  </ul></li>
  <li><a href="#pixelwise" id="toc-pixelwise" class="nav-link" data-scroll-target="#pixelwise">Pixelwise</a>
  <ul class="collapse">
  <li><a href="#crossover" id="toc-crossover" class="nav-link" data-scroll-target="#crossover">Crossover</a></li>
  <li><a href="#mutation" id="toc-mutation" class="nav-link" data-scroll-target="#mutation">Mutation</a></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">Results</a></li>
  </ul></li>
  <li><a href="#polygons" id="toc-polygons" class="nav-link" data-scroll-target="#polygons">Polygons</a>
  <ul class="collapse">
  <li><a href="#individuals" id="toc-individuals" class="nav-link" data-scroll-target="#individuals">Individuals</a></li>
  <li><a href="#crossover-1" id="toc-crossover-1" class="nav-link" data-scroll-target="#crossover-1">Crossover</a></li>
  <li><a href="#mutation-1" id="toc-mutation-1" class="nav-link" data-scroll-target="#mutation-1">Mutation</a></li>
  <li><a href="#penalty" id="toc-penalty" class="nav-link" data-scroll-target="#penalty">Penalty</a></li>
  <li><a href="#population-crossover" id="toc-population-crossover" class="nav-link" data-scroll-target="#population-crossover">Population crossover</a></li>
  <li><a href="#results-1" id="toc-results-1" class="nav-link" data-scroll-target="#results-1">Results</a></li>
  <li><a href="#future-improvements" id="toc-future-improvements" class="nav-link" data-scroll-target="#future-improvements">Future improvements</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block page-columns page-full" id="quarto-document-content">




<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>All code for this project can be found my <a href="https://github.com/Baukebrenninkmeijer/genetic-algorithms">github page</a></p>
</div>
</div>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<div id="fig-4dots-endstate" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/genetic-algorithms/4dots_final_state.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;1: Best individual, target and two loss metrics</figcaption>
</figure>
</div>
<p>Genetic algorithms are a beautiful subset in the machine learning domain, that use evolutionairy techniques to arrive to solutions that other algorithms have trouble at. These techniques include the combining of solutions, often called crossover, and the slightly altering of solutions, called mutations.</p>
<p>In this post, I’ll show two versions genetic algorithms that can be used for image reconstruction given a target image. In the real world, it will have few applications but it’s a great theoretical exercise and practice for understanding of the algorithms and image manipulation. However, they are unmistakingly usefull and have been applied in many domains, one being Neural Architecture Search, a method to find the best architecture for a neural network given a specific problem.</p>
<p>While other optimization methods, such a gradient descent, are incredibly powerful for problems that provide a smooth non-stochastic optimization curve, they frequently lack the variance needed for problems with solutions not easily findable following a single trajectory in parameter space. This is where genetic algorithms can provide unexpected solutions.</p>
<p>As in nature, genetic algorithms are based on natural selection and survival of the fittest. That means that each iteration, we select the best candidates for the problem at hand and continue with those. Each individual represents a solutions, and by slightly altering and combining solutions we hope to come to a better solution each iteration. As you can understand, this is a very generic approach that can be applied to all types of problems.</p>
<section id="the-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="the-algorithm">The algorithm</h3>
<p>Generally, the algorithms for genetic algorithms follows roughly the same outline and is as follows:</p>
<pre><code>pop = create initial popluation with n individuals

for i in n_iterations:
    1. randomly combine/reproduce individuals
    2. randomly mutate individuals
    3. retain fittest individuals</code></pre>
</section>
<section id="mutations" class="level3">
<h3 class="anchored" data-anchor-id="mutations">Mutations</h3>
<p>Let’s start with the most simple version of changes made to candidates: mutations. In any organism with DNA (or some form of it), we see mutations; slight changes in the genetic code. In organism, it’s typically the results of an incorrect copy of DNA code, but in this case we are intentionally applying mutation to create slight variations.</p>
<p>For human cells, a mutated cell can start to misbehave, which is generally cleaned up by our immune system. However, sometimes they’re missed or not easy to clean up and can lead to serious consequences such as cancer. We also know mutations from sci-fi and monster stories, which result in zombies and the like, but that’s unfortunately not what we are talking about today.</p>
</section>
<section id="procreation" class="level3">
<h3 class="anchored" data-anchor-id="procreation">Procreation</h3>
<p>Procreation is very important for this algorithm, because it allows the combining of two (or more) individuals into a new individual. Hopefully, this leads to to an individual that has all good qualities of their parents and none of the bad. In the rest of this post, the terms procreation, crossover and combine are used interchangeably for this concept.</p>
<p>An example with two individuals and their crossover. In this example, and individual is defined by its genes: 4 binary digits. The crossover in this case is just taking the first two digits of the first individual and the latter two of the second individual.</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a>ind1 <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb2-2"><a href="#cb2-2"></a>ind2 <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>]</span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="kw">def</span> crossover(a, b):</span>
<span id="cb2-5"><a href="#cb2-5"></a>  <span class="cf">return</span> a[:<span class="dv">2</span>] <span class="op">+</span> b[<span class="dv">2</span>:]</span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="bu">print</span>(<span class="ss">f'Result of crossover: </span><span class="sc">{</span>crossover(ind1, ind2)<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Result of crossover: [0, 0, 1, 1]</code></pre>
</div>
</div>
</section>
<section id="fitness-function" class="level3">
<h3 class="anchored" data-anchor-id="fitness-function">Fitness function</h3>
<p>To assess which individuals are the most fit, you need some metric. Depending on the problem, naturally you can use many different versions. In our case, image reconstruction, we are going to use the mean-squared error of the pixel values <span class="math inline">\(l = \frac{1}{n} \sum_{i=1}^{n}(c_i - T)^2\)</span> where <span class="math inline">\(n\)</span> is the size of the population, <span class="math inline">\(c_i\)</span> is candidate <span class="math inline">\(i\)</span> and <span class="math inline">\(T\)</span> the target image. This works nicely with our data and as always, penalizes the largest errors the most.</p>
</section>
</section>
<section id="pixelwise" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="pixelwise">Pixelwise</h2>
<p>In this method, we try to recreate the target image by manipulating individual pixels and comibing whole pixel arrays. The genes of an individual is a pixel array the size of the target image. For some RGB image, this will be a three dimensional, for example (200, 200, 3).</p>
<p>Let’s first deine a pixel individual and set its genes to the shape that we want. We also give an option to pass genes, which is handy for the crossover step later. Lastly, we define that probability to mutate <code>mutate_p</code> and the delta of a mutation <code>mutate_d</code>. The main methods of the individual are already defined here as well.</p>
<div class="cell column-page" data-execution_count="3">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">class</span> PixelIndividual:</span>
<span id="cb4-2"><a href="#cb4-2"></a>    <span class="co">"""Individual with pixel grid for genes."""</span></span>
<span id="cb4-3"><a href="#cb4-3"></a></span>
<span id="cb4-4"><a href="#cb4-4"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(</span>
<span id="cb4-5"><a href="#cb4-5"></a>        <span class="va">self</span>,</span>
<span id="cb4-6"><a href="#cb4-6"></a>        shape: Tuple,</span>
<span id="cb4-7"><a href="#cb4-7"></a>        genes: np.ndarray <span class="op">|</span> <span class="va">None</span> <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb4-8"><a href="#cb4-8"></a>        mutate_d: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.05</span>,</span>
<span id="cb4-9"><a href="#cb4-9"></a>        mutate_p: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb4-10"><a href="#cb4-10"></a>    ):</span>
<span id="cb4-11"><a href="#cb4-11"></a>        <span class="va">self</span>.shape <span class="op">=</span> shape</span>
<span id="cb4-12"><a href="#cb4-12"></a>        <span class="va">self</span>.mutate_d <span class="op">=</span> mutate_d</span>
<span id="cb4-13"><a href="#cb4-13"></a>        <span class="va">self</span>.mutate_p <span class="op">=</span> mutate_p</span>
<span id="cb4-14"><a href="#cb4-14"></a>        <span class="va">self</span>.genes <span class="op">=</span> np.random.rand(<span class="op">*</span>shape).astype(np.float32) <span class="cf">if</span> <span class="kw">not</span> genes <span class="cf">else</span> genes</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="crossover" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="crossover">Crossover</h3>
<p>The second method is our choice of what happens during crossover. How to implement a crossover function is really up to the person working on the problem. Initially I just took the pixelwise mean of both parents, but that seemed to always kind of move towards hovering around 0.5, which is maybe logical, but definitely undesirable. In this version, I chose to randomly take each pixel from either parent. This seems to work fairly well but you can use many other versions so make sure to play around with this a bit yourself. The <code>filter_arr</code> creates an array of random zeros and ones. We use it as a filter to decide which value to pick.</p>
<div class="cell column-page" data-execution_count="4">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a> <span class="kw">def</span> crossover(<span class="va">self</span>, other: PixelIndividual) <span class="op">-&gt;</span> PixelIndividual:</span>
<span id="cb5-2"><a href="#cb5-2"></a>        filter_arr <span class="op">=</span> np.random.randint(low<span class="op">=</span><span class="dv">0</span>, high<span class="op">=</span><span class="dv">2</span>, size<span class="op">=</span><span class="va">self</span>.genes.shape)</span>
<span id="cb5-3"><a href="#cb5-3"></a>        output <span class="op">=</span> np.where(filter_arr, <span class="va">self</span>.genes, other.genes)</span>
<span id="cb5-4"><a href="#cb5-4"></a>        <span class="cf">return</span> PixelIndividual(shape<span class="op">=</span><span class="va">self</span>.shape, genes<span class="op">=</span>output)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="mutation" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="mutation">Mutation</h3>
<p>Then, onto the mutation part. We create some noise of a certain magnitude, shift it so the mean is zero and half of it is negative and add it to the existing pixel values of said candidate. In the plot below you can see the distribution of a mutation for an individual with 100x100 grid as genes. I have chosen a uniform distribution for this, but again, you can choose others such as normal. However, the domain of the uniform distribution is simple and intuitive. For example, scaling an uniform distribution with 0.2 will have a magnitude of 0.2 as well, ranging from 0 to 0.2 distributed evenly. So you can see why working with this distribution is nice.</p>
<div class="cell" data-execution_count="5">
<div class="cell-output cell-output-display">
<p><img src="2023-02-15-genetic-algorithms_files/figure-html/cell-6-output-1.png" width="593" height="449"></p>
</div>
</div>
<p>As a last step, we apply the mutation and clip the values to the range [0, 1]. This is because otherwise we can mutate outside of the colour boundaries of an image, which will be clipped when shown as an image anyway. The domain for pixel values with a float is [0, 1] or [0, 255] for integer values, and plotting libraries like matplotlib will clip values for you if you don’t. To prevent hidden problems, we already make sure the domains and datatypes are correct.</p>
<div class="cell column-page" data-execution_count="6">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a>    <span class="kw">def</span> mutate(<span class="va">self</span>):</span>
<span id="cb6-2"><a href="#cb6-2"></a>        <span class="cf">if</span> <span class="va">self</span>.mutate_p <span class="op">&gt;</span> np.random.rand():</span>
<span id="cb6-3"><a href="#cb6-3"></a>            <span class="va">self</span>.mutation <span class="op">=</span> (np.random.rand(<span class="op">*</span><span class="va">self</span>.shape) <span class="op">*</span> <span class="va">self</span>.mutate_d) <span class="op">-</span> (<span class="va">self</span>.mutate_d <span class="op">*</span> <span class="fl">0.5</span>)</span>
<span id="cb6-4"><a href="#cb6-4"></a>            <span class="va">self</span>.mutation <span class="op">=</span> <span class="va">self</span>.mutation.astype(np.float32)</span>
<span id="cb6-5"><a href="#cb6-5"></a>            <span class="va">self</span>.genes <span class="op">=</span> np.clip(<span class="va">self</span>.genes <span class="op">+</span> <span class="va">self</span>.mutation, a_min<span class="op">=</span><span class="fl">0.0</span>, a_max<span class="op">=</span><span class="fl">1.0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Because I encountered a lot of datatype issues, such as float64 and integer reprentations, I cast most computation to float32 and also do a dtype check in the <code>compute_fitness</code> method. This is because this is the last step of each iteration, and generally should represent if things went correctly.</p>
<p>The fitness method is in this case the mean-squared error.</p>
<div class="cell column-page" data-execution_count="7">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a>    <span class="kw">def</span> compute_fitness(<span class="va">self</span>, target: np.ndarray):</span>
<span id="cb7-2"><a href="#cb7-2"></a>        <span class="cf">assert</span> <span class="va">self</span>.genes.dtype.name <span class="op">==</span> <span class="st">'float32'</span>, (</span>
<span id="cb7-3"><a href="#cb7-3"></a>            <span class="ss">f'genes dtype should be float32 but found </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>genes<span class="sc">.</span>dtype<span class="sc">.</span>name<span class="sc">}</span><span class="ss">.'</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>        )</span>
<span id="cb7-5"><a href="#cb7-5"></a>        <span class="va">self</span>.fitness <span class="op">=</span> ((<span class="va">self</span>.genes <span class="op">-</span> target) <span class="op">**</span> <span class="dv">2</span>).mean()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="results" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="results">Results</h3>
<p>Some of the results are pretty cool. With smaller images, it works quite fast but for larger it can take several hours to several days to get any good results. The mario image took around 12 hours to create, and while you can clearly see the outlines, it’s far from perfect.</p>
<section id="toy-example-10x10-matrix" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="toy-example-10x10-matrix">Toy example: 10x10 matrix</h4>
<p>This run is for just 200 iterations and takes around a minute. The right most graph shows the fitness distribution of the current population. The fitness function here was sum of squared errors, rather than mean.</p>
<div id="fig-4dots-training" class="quarto-figure quarto-figure-center column-screen anchored page-columns page-full">
<figure class="figure page-columns page-full">
<p class="page-columns page-full"><img src="images/genetic-algorithms/4dots_training.gif" class="column-screen img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;2: Best individual, target and two loss metrics of a 10x10 pixel grid with 4 dots</figcaption>
</figure>
</div>
</section>
<section id="slightly-less-toy-example-100x100-matrix-with-gradient" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="slightly-less-toy-example-100x100-matrix-with-gradient">Slightly less toy example: 100x100 matrix with gradient</h4>
<p>This run is for 10k iterations and takes around a 1-2 hours. The right most graph shows the fitness distribution of the current population. You can see the graph struggle to show a clear distribution. This seems to mean that the whole distribution is very close, although the values on the x-axis are pretty big, so I’m not entirely sure why it cannot show a good distribution.</p>
<p>You can see an immediate steep decline in loss, which is attributed to the initial high variety in individuals. The further the iterations go, the more we have selected the optimal individuals and the more of the population can be considered brothers and sisters of the original best individual. When the problem is complex and high-dimensional, this happens more and more, since it’s quite unlikely that other candidates can present a better solution from mutation within the timeframe of the best candidate taking over the population.</p>
<div id="fig-gradient-training" class="quarto-figure quarto-figure-center column-screen anchored page-columns page-full">
<figure class="figure page-columns page-full">
<p class="page-columns page-full"><img src="images/genetic-algorithms/gradient_training_optimized_compressed.gif" class="column-screen img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;3: Best individual, target and two loss metrics of a 100x100 pixel grid with gradient</figcaption>
</figure>
</div>
</section>
<section id="the-real-deal" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="the-real-deal">The real deal</h4>
<div id="fig-gradient-training" class="quarto-figure quarto-figure-center column-screen anchored page-columns page-full">
<figure class="figure page-columns page-full">
<p class="page-columns page-full"><img src="images/genetic-algorithms/mario_training_optimized.gif" class="column-screen img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4: Best individual, target and two loss metrics of Mario</figcaption>
</figure>
</div>
</section>
</section>
</section>
<section id="polygons" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="polygons">Polygons</h2>
<p>The second method of approximating images is using a population of polygons. Polygons are shapes with 3 or more points connected in no specific order. This could be a triangle, square but also also an hourglass shape has 4 points where the middle lines cross. While we could randomly add or remove points, in this case I chose to leave it at 3 points.</p>
<section id="individuals" class="level3">
<h3 class="anchored" data-anchor-id="individuals">Individuals</h3>
<p>The individuals here are slightly more complex than the pixel versions. That is because the polygons have their own class. Each individual’s genes are composed of a starting amount of 10-20 polygons.</p>
</section>
<section id="crossover-1" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="crossover-1">Crossover</h3>
<p>Crossovers are done simply by randomly taking a polygon of either parents. If one of the parents has more polygons, we randomly add polygons in those indices as well.</p>
<div class="cell column-page" data-execution_count="8">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">def</span> crossover(<span class="va">self</span>, other):</span>
<span id="cb8-2"><a href="#cb8-2"></a>    child <span class="op">=</span> copy.deepcopy(<span class="va">self</span>)</span>
<span id="cb8-3"><a href="#cb8-3"></a>    <span class="cf">for</span> idx, poly <span class="kw">in</span> <span class="bu">enumerate</span>(other.polygons):</span>
<span id="cb8-4"><a href="#cb8-4"></a>        <span class="cf">if</span> <span class="fl">0.5</span> <span class="op">&lt;</span> np.random.random():</span>
<span id="cb8-5"><a href="#cb8-5"></a>            <span class="cf">try</span>:</span>
<span id="cb8-6"><a href="#cb8-6"></a>                child.polygons[idx] <span class="op">=</span> poly</span>
<span id="cb8-7"><a href="#cb8-7"></a>            <span class="cf">except</span>:</span>
<span id="cb8-8"><a href="#cb8-8"></a>                <span class="co"># When idx is out of range of child.polygons, we append.</span></span>
<span id="cb8-9"><a href="#cb8-9"></a>                child.polygons.append(poly)</span>
<span id="cb8-10"><a href="#cb8-10"></a>    <span class="cf">return</span> child</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="mutation-1" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="mutation-1">Mutation</h3>
<section id="individual" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="individual">Individual</h4>
<p>Mutation in this case has to be done at the “genes” level rather than the individual level. So the <code>mutate</code> method of the individuals here is surpisingly simple.</p>
<div class="cell column-page" data-execution_count="9">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">def</span> mutate(<span class="va">self</span>):</span>
<span id="cb9-2"><a href="#cb9-2"></a>    <span class="co">"""mutate method for an individual"""</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>    <span class="cf">for</span> polygon <span class="kw">in</span> <span class="va">self</span>.polygons:</span>
<span id="cb9-4"><a href="#cb9-4"></a>        polygon.mutate()</span>
<span id="cb9-5"><a href="#cb9-5"></a></span>
<span id="cb9-6"><a href="#cb9-6"></a>    <span class="co"># deletion chance</span></span>
<span id="cb9-7"><a href="#cb9-7"></a>    <span class="cf">if</span> np.random.random() <span class="op">&lt;</span> <span class="va">self</span>.add_or_del_p <span class="kw">and</span> <span class="bu">len</span>(<span class="va">self</span>.polygons) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb9-8"><a href="#cb9-8"></a>        idx <span class="op">=</span> np.random.randint(<span class="dv">0</span>, <span class="bu">len</span>(<span class="va">self</span>.polygons) <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb9-9"><a href="#cb9-9"></a>        <span class="va">self</span>.polygons.pop(idx)</span>
<span id="cb9-10"><a href="#cb9-10"></a></span>
<span id="cb9-11"><a href="#cb9-11"></a>    <span class="co"># addition chance</span></span>
<span id="cb9-12"><a href="#cb9-12"></a>    <span class="cf">if</span> np.random.random() <span class="op">&lt;</span> <span class="va">self</span>.add_or_del_p:</span>
<span id="cb9-13"><a href="#cb9-13"></a>        <span class="va">self</span>.polygons.append(</span>
<span id="cb9-14"><a href="#cb9-14"></a>            Polygon(</span>
<span id="cb9-15"><a href="#cb9-15"></a>                canvas_size<span class="op">=</span><span class="va">self</span>.canvas_size,</span>
<span id="cb9-16"><a href="#cb9-16"></a>                mutate_delta<span class="op">=</span><span class="va">self</span>.mutate_delta,</span>
<span id="cb9-17"><a href="#cb9-17"></a>                mutate_p<span class="op">=</span><span class="va">self</span>.mutate_p,</span>
<span id="cb9-18"><a href="#cb9-18"></a>            )</span>
<span id="cb9-19"><a href="#cb9-19"></a>        )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>There are three steps:</p>
<ol type="1">
<li>Mutate each polygon individually (i.e.&nbsp;change the location of the points and the colour)</li>
<li>Randomly delete a polygon</li>
<li>Randomly add a polygon</li>
</ol>
</section>
<section id="genes" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="genes">Genes</h4>
<div class="cell column-page" data-execution_count="10">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a>    <span class="kw">def</span> mutate(<span class="va">self</span>):</span>
<span id="cb10-2"><a href="#cb10-2"></a>        <span class="co">"""mutate method for a gene"""</span></span>
<span id="cb10-3"><a href="#cb10-3"></a>        changed <span class="op">=</span> <span class="va">False</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>        <span class="cf">for</span> coord <span class="kw">in</span> <span class="va">self</span>.coords:</span>
<span id="cb10-5"><a href="#cb10-5"></a>            <span class="cf">if</span> <span class="va">self</span>.mutate_p <span class="op">&gt;</span> np.random.random():</span>
<span id="cb10-6"><a href="#cb10-6"></a>                changed <span class="op">=</span> <span class="va">True</span></span>
<span id="cb10-7"><a href="#cb10-7"></a>                coord[<span class="dv">0</span>] <span class="op">+=</span> np.random.randint(<span class="dv">0</span>, <span class="bu">int</span>(<span class="va">self</span>.x_size <span class="op">*</span> <span class="va">self</span>.mutate_d)) <span class="op">-</span> <span class="bu">int</span>(</span>
<span id="cb10-8"><a href="#cb10-8"></a>                    <span class="va">self</span>.x_size <span class="op">*</span> <span class="va">self</span>.mutate_d <span class="op">*</span> <span class="fl">0.5</span></span>
<span id="cb10-9"><a href="#cb10-9"></a>                )</span>
<span id="cb10-10"><a href="#cb10-10"></a>                coord[<span class="dv">0</span>] <span class="op">=</span> np.clip(coord[<span class="dv">0</span>], <span class="dv">0</span>, <span class="va">self</span>.x_size)</span>
<span id="cb10-11"><a href="#cb10-11"></a>                coord[<span class="dv">1</span>] <span class="op">+=</span> np.random.randint(<span class="dv">0</span>, <span class="bu">int</span>(<span class="va">self</span>.y_size <span class="op">*</span> <span class="va">self</span>.mutate_d)) <span class="op">-</span> <span class="bu">int</span>(<span class="va">self</span>.y_size <span class="op">*</span> <span class="va">self</span>.mutate_d <span class="op">*</span> <span class="fl">0.5</span>)</span>
<span id="cb10-12"><a href="#cb10-12"></a>                coord[<span class="dv">1</span>] <span class="op">=</span> np.clip(coord[<span class="dv">1</span>], <span class="dv">0</span>, <span class="va">self</span>.y_size)</span>
<span id="cb10-13"><a href="#cb10-13"></a></span>
<span id="cb10-14"><a href="#cb10-14"></a>        <span class="cf">if</span> <span class="va">self</span>.mutate_p <span class="op">&gt;</span> np.random.random():</span>
<span id="cb10-15"><a href="#cb10-15"></a>            <span class="va">self</span>.color <span class="op">+=</span> (np.random.random(<span class="va">self</span>.color_c) <span class="op">*</span> <span class="va">self</span>.mutate_d) <span class="op">-</span> (<span class="va">self</span>.mutate_d <span class="op">*</span> <span class="fl">0.5</span>)</span>
<span id="cb10-16"><a href="#cb10-16"></a>            <span class="va">self</span>.color <span class="op">=</span> np.clip(<span class="va">self</span>.color, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb10-17"><a href="#cb10-17"></a></span>
<span id="cb10-18"><a href="#cb10-18"></a>        <span class="cf">if</span> changed:</span>
<span id="cb10-19"><a href="#cb10-19"></a>            <span class="cf">assert</span> (<span class="dv">0</span> <span class="op">&lt;=</span> <span class="va">self</span>.color).<span class="bu">all</span>() <span class="kw">and</span> (<span class="va">self</span>.color <span class="op">&lt;=</span> <span class="fl">1.0</span>).<span class="bu">all</span>()</span>
<span id="cb10-20"><a href="#cb10-20"></a>            <span class="cf">for</span> x, y <span class="kw">in</span> <span class="va">self</span>.coords:</span>
<span id="cb10-21"><a href="#cb10-21"></a>                <span class="cf">assert</span> <span class="dv">0</span> <span class="op">&lt;=</span> x <span class="op">&lt;=</span> <span class="va">self</span>.x_size</span>
<span id="cb10-22"><a href="#cb10-22"></a>                <span class="cf">assert</span> <span class="dv">0</span> <span class="op">&lt;=</span> y <span class="op">&lt;=</span> <span class="va">self</span>.y_size</span>
<span id="cb10-23"><a href="#cb10-23"></a>            <span class="va">self</span>.calc_size()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This mutation is conceptually straight forward:</p>
<ol type="1">
<li>Mutate the location of each point with <code>mutate_d</code> as the fractional delta (i.e.&nbsp;0.1 is 10% variation in position) based on the whole canvas width and height.</li>
<li>Mutate the colour of each polygon slightly. The approach is similar to the location, with <code>mutate_d</code> indicating a fraction delta. In this case the max is 1, so taking the random output is enough here. Because our colour is RGB, we input the <code>self.color_c</code> into random to get the desired number of channels (3).</li>
</ol>
<p>To see what this looks like if we just have some polygons and keep mutating them.</p>
<div id="fig-polygon-mutation" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="images/genetic-algorithms/polygon_mutation.gif" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;5: Mutations of several polygons over time</figcaption>
</figure>
</div>
</section>
</section>
<section id="penalty" class="level3">
<h3 class="anchored" data-anchor-id="penalty">Penalty</h3>
<p>Because we do not want a model that just keeps adding polygons, we will penalize based on the number of polygons. The problem here is that you do not want to penalize it too much. If the difference of the penalty of one extra polygon is greater than the average difference in fitness between different individuals, then just removing a polygon will almost always be the best option. This happened at numerous attempts, and you just end up with an empty white grid very fast.</p>
<p>The penalty was calculated as follows: <span class="math inline">\(p = 1 + \lvert pop\rvert * r_{pen}\)</span> where <span class="math inline">\(p\)</span> is the eventual penalty, <span class="math inline">\(\lvert pop\rvert\)</span> is the total population size and <span class="math inline">\(r_{pen}\)</span> is the penalty rate. The penalty is applied as multiplier to the loss, which is the same as before: MSE. Hence the computation becomes <span class="math inline">\(L_{pen} = L * p\)</span> where <span class="math inline">\(L\)</span> and <span class="math inline">\(L_{pen}\)</span> indicate the loss initially and penalized, respectively.</p>
</section>
<section id="population-crossover" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="population-crossover">Population crossover</h3>
<p>The last interesting section is how to achieve the population crossover here.</p>
<div class="cell column-page" data-execution_count="11">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a>    <span class="kw">def</span> combine(<span class="va">self</span>):</span>
<span id="cb11-2"><a href="#cb11-2"></a>        pairs <span class="op">=</span> <span class="bu">list</span>(permutations(<span class="va">self</span>.pop, r<span class="op">=</span><span class="dv">2</span>))</span>
<span id="cb11-3"><a href="#cb11-3"></a>        sample_pairs <span class="op">=</span> random.choices(pairs, k<span class="op">=</span><span class="va">self</span>.popsize)  <span class="co"># Sample popsize pairs out of all combinations. N out of N*(N-1)</span></span>
<span id="cb11-4"><a href="#cb11-4"></a></span>
<span id="cb11-5"><a href="#cb11-5"></a>        <span class="co"># sample all permutations in the sample_top_n percent of the population.</span></span>
<span id="cb11-6"><a href="#cb11-6"></a>        sample_pairs <span class="op">+=</span> <span class="bu">list</span>(</span>
<span id="cb11-7"><a href="#cb11-7"></a>            permutations(<span class="va">self</span>.pop[: <span class="bu">int</span>(<span class="bu">len</span>(<span class="va">self</span>.pop) <span class="op">*</span> <span class="va">self</span>.sample_top_n)], r<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb11-8"><a href="#cb11-8"></a>        )</span>
<span id="cb11-9"><a href="#cb11-9"></a></span>
<span id="cb11-10"><a href="#cb11-10"></a>        <span class="co"># Create copies of the copy_top_perc fraction of the population</span></span>
<span id="cb11-11"><a href="#cb11-11"></a>        children <span class="op">=</span> [</span>
<span id="cb11-12"><a href="#cb11-12"></a>            <span class="va">self</span>.get_best().copy() <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">max</span>(<span class="bu">int</span>(<span class="va">self</span>.copy_top_perc <span class="op">*</span> <span class="bu">len</span>(<span class="va">self</span>.pop)), <span class="dv">2</span>))</span>
<span id="cb11-13"><a href="#cb11-13"></a>        ]</span>
<span id="cb11-14"><a href="#cb11-14"></a></span>
<span id="cb11-15"><a href="#cb11-15"></a>        <span class="co"># Add crossover of the picked pairs and add to the children.</span></span>
<span id="cb11-16"><a href="#cb11-16"></a>        children <span class="op">+=</span> [x.crossover(y) <span class="cf">for</span> (x, y) <span class="kw">in</span> sample_pairs]</span>
<span id="cb11-17"><a href="#cb11-17"></a>        <span class="va">self</span>.pop <span class="op">+=</span> children</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>As stated before, we want to have a good balance between selecting fit individuals but also retaining the variance of the whole population. I try to find a balance in this by both selecting from the total population while also sampling the top <code>x</code> percent more than the rest and even copying the top <code>y</code> percent.</p>
</section>
<section id="results-1" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="results-1">Results</h3>
<section id="polygon-fox" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="polygon-fox">Polygon Fox</h4>
<p>Since we are playing with polygons, I decided a target that was made of polygons might be suitable. This fox has some clear advantages for polygons, with big blue areas and a pointy bright fox head in the middle.</p>
<div id="fig-polygon-fox" class="quarto-figure quarto-figure-center column-screen anchored page-columns page-full">
<figure class="figure page-columns page-full">
<p class="page-columns page-full"><img src="images/genetic-algorithms/fox_training_optimized.gif" class="column-screen img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;6: Best individual using polygon approach, target and two loss metrics of a fox image</figcaption>
</figure>
</div>
<p>We observe a sharp incline in the number of polygons, even though it does not really seem to result in a clear improvement in fit. It seems the penalty was not tuned appropriate for this case. In this middle, we do see the fox head shape become apparant, but the algorithm fails to fill in the finer details of the head.</p>
</section>
<section id="rick-morty" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="rick-morty">Rick &amp; Morty</h4>
<div id="fig-polygon-rick" class="quarto-figure quarto-figure-center column-screen anchored page-columns page-full">
<figure class="figure page-columns page-full">
<p class="page-columns page-full"><img src="images/genetic-algorithms/rick_polygon_optimized.gif" class="column-screen img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;7: Best individual using polygon approach, target and two loss metrics of a rick and morty image</figcaption>
</figure>
</div>
<p>It’s clear that this image has too much detail for this algorithms. Many of the planes are too small to easily get picked up by the mean-square-error reduction. The best fit is often achieved by having big polygons match up with the background. Additionally, the meandering of the number of polygons is a clear indication that the penalty was nicely balanced, since there was no clear preference.</p>
</section>
<section id="hyper-parameter-grid-search" class="level4">
<h4 class="anchored" data-anchor-id="hyper-parameter-grid-search">Hyper parameter grid search</h4>
<div class="cell" data-execution_count="12">
<div class="cell-output cell-output-display">

<div>                            <div id="c5c2c674-3592-4caf-80cf-9d720f73af68" class="plotly-graph-div" style="height:525px; width:100%;"></div>            <script type="text/javascript">                require(["plotly"], function(Plotly) {                    window.PLOTLYENV=window.PLOTLYENV || {};                                    if (document.getElementById("c5c2c674-3592-4caf-80cf-9d720f73af68")) {                    Plotly.newPlot(                        "c5c2c674-3592-4caf-80cf-9d720f73af68",                        [{"dimensions":[{"label":"mutate_d","values":[0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2]},{"label":"mutate_p","values":[0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3]},{"label":"copy_top_perc","values":[0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15,0.15]},{"label":"sample_top_n","values":[0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.30000000000000004,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4]},{"label":"n_polygons","values":[10,10,10,10,15,15,15,15,20,20,20,20,25,25,25,25,10,10,10,10,15,15,15,15,20,20,20,20,25,25,25,25,10,10,10,10,15,15,15,15,20,20,20,20,25,25,25,25,10,10,10,10,15,15,15,15,20,20,20,20,25,25,25,25,10,10,10,10,15,15,15,15,20,20,20,20,25,25,25,25,10,10,10,10,15,15,15,15,20,20,20,20,25,25,25,25,10,10,10,10,15,15,15,15,20,20,20,20,25,25,25,25,10,10,10,10,15,15,15,15,20,20,20,20,25,25,25,25,10,10,10,10,15,15,15,15,20,20,20,20,25,25,25,25,10,10,10,10,15,15,15,15,20,20,20,20,25,25,25,25,10,10,10,10,15,15,15,15,20,20,20,20,25,25,25,25,10,10,10,10,15,15,15,15,20,20,20,20,25,25,25,25,10,10,10,10,15,15,15,15,20,20,20,20,25,25,25,25,10,10,10,10,15,15,15,15,20,20,20,20,25,25,25,25,10,10,10,10,15,15,15,15,20,20,20,20,25,25,25,25,10,10,10,10,15,15,15,15,20,20,20,20,25,25,25,25,10,10,10,10,15,15,15,15,20,20,20,20,25,25,25,25,10,10,10,10,15,15,15,15,20,20,20,20,25,25,25,25,10,10,10,10,15,15,15,15,20,20,20,20,25,25,25,25,10,10,10,10,15,15,15,15,20,20,20,20,25,25,25,25]},{"label":"add_or_del_p","values":[0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001,0.1,0.30000000000000004,0.5000000000000001,0.7000000000000001]},{"label":"fitness","values":[0.0870674408818445,0.10346521216259054,0.10741763549700617,0.12624478807592132,0.09674633260075123,0.10441234594217261,0.10676590047377824,0.12119928984734683,0.08603758196654504,0.09935612523522536,0.11165461246600115,0.12461275523666956,0.09487399851499755,0.1054828983376067,0.11737611154509162,0.12498029511708793,0.08499045968864505,0.09157038837284627,0.1027840918552855,0.10392337671455934,0.09172699205992066,0.0943286197464729,0.09374910501156028,0.11599839397301308,0.08056093648645406,0.10065565307332795,0.10572287752576122,0.10604171830544125,0.08584024994912463,0.09779332017852034,0.10009766148222345,0.11243191415282645,0.08089215939330656,0.09009290100091348,0.08826403825499539,0.09728843355631342,0.08644100600837455,0.09105222715505172,0.09792297242706602,0.10255106525424675,0.07833021494423283,0.08657686524183889,0.09434139755447735,0.09481152115692264,0.07570464736017005,0.08748033226935224,0.09490340132129009,0.09982527397584619,0.08212085242457456,0.08751100329664264,0.08650230612452921,0.09519777469548507,0.08147932880910236,0.0884611725549033,0.09275958803417744,0.09410548847835565,0.08174884997426385,0.08616050687524839,0.08991240245447202,0.10309980314822603,0.07796395294267805,0.08653000567351557,0.08745114558033851,0.09156756586842262,0.07660437973988998,0.08418840468058282,0.08915044081289374,0.09027247131658381,0.08052096001337623,0.08393889170527971,0.0887695319838812,0.09011462951993207,0.07891984467628807,0.08477562630802243,0.0893028652869671,0.09083350653529979,0.07546493921656437,0.08488933807806583,0.08872599662529605,0.09281681194452564,0.09370845399729244,0.10730435347293193,0.11108832650501135,0.11481831527426016,0.09234871319742916,0.10797730635181152,0.11418820961391456,0.12912562601061472,0.09127984525652716,0.09614444321794513,0.11968065978631477,0.12261993035254529,0.08756781105994635,0.10878400150258563,0.10747782928850065,0.11170160531158561,0.08961511370167992,0.09373672799574795,0.10622288021470253,0.10797467780590002,0.08151670271829928,0.0926195542219157,0.09782113587072803,0.1075941414850973,0.08689129041516892,0.08733026123019554,0.09299347171958885,0.12027565761024743,0.0872328320995802,0.09733596243766648,0.09489218501432536,0.09421603692482212,0.08143228142852246,0.0936626802180976,0.0965983527694953,0.1047850336729669,0.0829330375756016,0.09031513216824945,0.09537998295097477,0.09027116028405362,0.08230147850541661,0.08785200528991799,0.09061668674904995,0.101834385630373,0.08156040403475803,0.08740874875791156,0.09836862704895478,0.09370178040158551,0.08249819640362084,0.0878082406790756,0.09040579297180774,0.09587413591763173,0.08112377934462192,0.08669240313586679,0.0901814971234887,0.09317064503654639,0.08083437050372706,0.08177812390624846,0.08826651904475648,0.0913455588828179,0.08218388179128185,0.08447336255068975,0.08789413491600062,0.09003431307672621,0.07906982754228647,0.08449004353162926,0.08842438132907883,0.09305505779311452,0.07569916661474604,0.07966701553371743,0.08626275066234185,0.08898895184133529,0.08099829183250208,0.08479856379781338,0.08646948214599971,0.09062334162701162,0.0829750951805293,0.08163960403513186,0.08707466920594466,0.09319845833711342,0.0925943458634419,0.09831270471467521,0.09538557130628195,0.11461699817360672,0.09539111293772234,0.0938185349999751,0.10998146322231142,0.1327134440900736,0.09237868693242143,0.0981052725844624,0.1082894128586765,0.11948847207838978,0.08556249708807824,0.09700610460464996,0.1029252714792824,0.1074722999875712,0.08680269167286297,0.10293831473053544,0.10861017340887064,0.09738484626414533,0.08763822959834952,0.08867616688370965,0.09912930823107034,0.10878642449023367,0.08750511924130012,0.09548025030123038,0.09911525765560013,0.0937596378220653,0.08148195710447702,0.09008710773775838,0.10626566852978604,0.11319268257868893,0.08241077449971934,0.09172879051569759,0.09458114855622743,0.10292704322458197,0.08390856290154416,0.08780110950222983,0.0922689056332672,0.09258904564252729,0.07916371359780354,0.09468373512334397,0.09338678258504093,0.10708687738823018,0.07797991260927892,0.08767877865501685,0.08978271501661941,0.09360892553437726,0.07968530893725936,0.085358644816129,0.09442850136911836,0.09249443482919045,0.0815868328493269,0.08232158538565335,0.09026893795955405,0.0918588140572604,0.07880072597007715,0.08412268735761318,0.08881728453451518,0.08968541109844633,0.0795269751289743,0.08354271004130184,0.08552825739924562,0.09232773482888958,0.08061603374088738,0.0846920676065404,0.08629367246381951,0.0894279131641245,0.07573474237919293,0.08351076555573744,0.08636010621185759,0.09007326550992015,0.08129407522036461,0.0839378268757179,0.09116873772142366,0.09228734053773724,0.07605176362394674,0.08692778976983097,0.08806445684039468,0.08855063991918166,0.08299306190116248,0.09491201885325079,0.09229578386874125,0.12020381754618753,0.08476500068906946,0.09587472317809596,0.1073720297825787,0.1058009634393549,0.08495089567385626,0.09123615134350492,0.10494858370160962,0.10615718802682779,0.09024876908765697,0.09394986240879119,0.1028258415628993,0.11768028679723856,0.09141463034001918,0.09523558560984352,0.09585879440447521,0.10453351776151475,0.07990705296359833,0.09406870372307018,0.09903216676622342,0.10606489973988328,0.0823379540734495,0.09180719613435813,0.09295127539538983,0.10098469561670396,0.0875850384858827,0.08946320869891275,0.09605605223598684,0.10143273303553199,0.07885991323386056,0.09210388993228334,0.08844591557130578,0.09568580643876168,0.08174666768753042,0.08531108599315478,0.09594813887434753,0.09566430445862524,0.08046803319530384,0.08895462787420613,0.09368970945597746,0.0983758779912811,0.0769116640900686,0.08663681390513941,0.09381394037358508,0.09298609236362657,0.07717183417328037,0.08141229615780372,0.09078501148794166,0.08789329005567945,0.0755729706502447,0.08604261246011759,0.09228383958187734,0.09804684021782226,0.07920543266079501,0.08649594087536451,0.09154827545839679,0.09463167573732374,0.07660321976654469,0.08380505801345153,0.09230936955515305,0.09565432297602529,0.07883698713827766,0.08515759990360873,0.0885980436445081,0.08800783551402011,0.07802369310055342,0.08124553168352386,0.08651144731652896,0.09703952624737683,0.08049797354856067,0.07940885081515174,0.08884251259390852,0.09558181523542743,0.07944225635522399,0.08317293166000662,0.0852328840763137,0.0858754079812289]}],"domain":{"x":[0.0,1.0],"y":[0.0,1.0]},"line":{"color":[0.0870674408818445,0.10346521216259054,0.10741763549700617,0.12624478807592132,0.09674633260075123,0.10441234594217261,0.10676590047377824,0.12119928984734683,0.08603758196654504,0.09935612523522536,0.11165461246600115,0.12461275523666956,0.09487399851499755,0.1054828983376067,0.11737611154509162,0.12498029511708793,0.08499045968864505,0.09157038837284627,0.1027840918552855,0.10392337671455934,0.09172699205992066,0.0943286197464729,0.09374910501156028,0.11599839397301308,0.08056093648645406,0.10065565307332795,0.10572287752576122,0.10604171830544125,0.08584024994912463,0.09779332017852034,0.10009766148222345,0.11243191415282645,0.08089215939330656,0.09009290100091348,0.08826403825499539,0.09728843355631342,0.08644100600837455,0.09105222715505172,0.09792297242706602,0.10255106525424675,0.07833021494423283,0.08657686524183889,0.09434139755447735,0.09481152115692264,0.07570464736017005,0.08748033226935224,0.09490340132129009,0.09982527397584619,0.08212085242457456,0.08751100329664264,0.08650230612452921,0.09519777469548507,0.08147932880910236,0.0884611725549033,0.09275958803417744,0.09410548847835565,0.08174884997426385,0.08616050687524839,0.08991240245447202,0.10309980314822603,0.07796395294267805,0.08653000567351557,0.08745114558033851,0.09156756586842262,0.07660437973988998,0.08418840468058282,0.08915044081289374,0.09027247131658381,0.08052096001337623,0.08393889170527971,0.0887695319838812,0.09011462951993207,0.07891984467628807,0.08477562630802243,0.0893028652869671,0.09083350653529979,0.07546493921656437,0.08488933807806583,0.08872599662529605,0.09281681194452564,0.09370845399729244,0.10730435347293193,0.11108832650501135,0.11481831527426016,0.09234871319742916,0.10797730635181152,0.11418820961391456,0.12912562601061472,0.09127984525652716,0.09614444321794513,0.11968065978631477,0.12261993035254529,0.08756781105994635,0.10878400150258563,0.10747782928850065,0.11170160531158561,0.08961511370167992,0.09373672799574795,0.10622288021470253,0.10797467780590002,0.08151670271829928,0.0926195542219157,0.09782113587072803,0.1075941414850973,0.08689129041516892,0.08733026123019554,0.09299347171958885,0.12027565761024743,0.0872328320995802,0.09733596243766648,0.09489218501432536,0.09421603692482212,0.08143228142852246,0.0936626802180976,0.0965983527694953,0.1047850336729669,0.0829330375756016,0.09031513216824945,0.09537998295097477,0.09027116028405362,0.08230147850541661,0.08785200528991799,0.09061668674904995,0.101834385630373,0.08156040403475803,0.08740874875791156,0.09836862704895478,0.09370178040158551,0.08249819640362084,0.0878082406790756,0.09040579297180774,0.09587413591763173,0.08112377934462192,0.08669240313586679,0.0901814971234887,0.09317064503654639,0.08083437050372706,0.08177812390624846,0.08826651904475648,0.0913455588828179,0.08218388179128185,0.08447336255068975,0.08789413491600062,0.09003431307672621,0.07906982754228647,0.08449004353162926,0.08842438132907883,0.09305505779311452,0.07569916661474604,0.07966701553371743,0.08626275066234185,0.08898895184133529,0.08099829183250208,0.08479856379781338,0.08646948214599971,0.09062334162701162,0.0829750951805293,0.08163960403513186,0.08707466920594466,0.09319845833711342,0.0925943458634419,0.09831270471467521,0.09538557130628195,0.11461699817360672,0.09539111293772234,0.0938185349999751,0.10998146322231142,0.1327134440900736,0.09237868693242143,0.0981052725844624,0.1082894128586765,0.11948847207838978,0.08556249708807824,0.09700610460464996,0.1029252714792824,0.1074722999875712,0.08680269167286297,0.10293831473053544,0.10861017340887064,0.09738484626414533,0.08763822959834952,0.08867616688370965,0.09912930823107034,0.10878642449023367,0.08750511924130012,0.09548025030123038,0.09911525765560013,0.0937596378220653,0.08148195710447702,0.09008710773775838,0.10626566852978604,0.11319268257868893,0.08241077449971934,0.09172879051569759,0.09458114855622743,0.10292704322458197,0.08390856290154416,0.08780110950222983,0.0922689056332672,0.09258904564252729,0.07916371359780354,0.09468373512334397,0.09338678258504093,0.10708687738823018,0.07797991260927892,0.08767877865501685,0.08978271501661941,0.09360892553437726,0.07968530893725936,0.085358644816129,0.09442850136911836,0.09249443482919045,0.0815868328493269,0.08232158538565335,0.09026893795955405,0.0918588140572604,0.07880072597007715,0.08412268735761318,0.08881728453451518,0.08968541109844633,0.0795269751289743,0.08354271004130184,0.08552825739924562,0.09232773482888958,0.08061603374088738,0.0846920676065404,0.08629367246381951,0.0894279131641245,0.07573474237919293,0.08351076555573744,0.08636010621185759,0.09007326550992015,0.08129407522036461,0.0839378268757179,0.09116873772142366,0.09228734053773724,0.07605176362394674,0.08692778976983097,0.08806445684039468,0.08855063991918166,0.08299306190116248,0.09491201885325079,0.09229578386874125,0.12020381754618753,0.08476500068906946,0.09587472317809596,0.1073720297825787,0.1058009634393549,0.08495089567385626,0.09123615134350492,0.10494858370160962,0.10615718802682779,0.09024876908765697,0.09394986240879119,0.1028258415628993,0.11768028679723856,0.09141463034001918,0.09523558560984352,0.09585879440447521,0.10453351776151475,0.07990705296359833,0.09406870372307018,0.09903216676622342,0.10606489973988328,0.0823379540734495,0.09180719613435813,0.09295127539538983,0.10098469561670396,0.0875850384858827,0.08946320869891275,0.09605605223598684,0.10143273303553199,0.07885991323386056,0.09210388993228334,0.08844591557130578,0.09568580643876168,0.08174666768753042,0.08531108599315478,0.09594813887434753,0.09566430445862524,0.08046803319530384,0.08895462787420613,0.09368970945597746,0.0983758779912811,0.0769116640900686,0.08663681390513941,0.09381394037358508,0.09298609236362657,0.07717183417328037,0.08141229615780372,0.09078501148794166,0.08789329005567945,0.0755729706502447,0.08604261246011759,0.09228383958187734,0.09804684021782226,0.07920543266079501,0.08649594087536451,0.09154827545839679,0.09463167573732374,0.07660321976654469,0.08380505801345153,0.09230936955515305,0.09565432297602529,0.07883698713827766,0.08515759990360873,0.0885980436445081,0.08800783551402011,0.07802369310055342,0.08124553168352386,0.08651144731652896,0.09703952624737683,0.08049797354856067,0.07940885081515174,0.08884251259390852,0.09558181523542743,0.07944225635522399,0.08317293166000662,0.0852328840763137,0.0858754079812289],"coloraxis":"coloraxis"},"name":"","type":"parcoords"}],                        {"template":{"data":{"histogram2dcontour":[{"type":"histogram2dcontour","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"choropleth":[{"type":"choropleth","colorbar":{"outlinewidth":0,"ticks":""}}],"histogram2d":[{"type":"histogram2d","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"heatmap":[{"type":"heatmap","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"heatmapgl":[{"type":"heatmapgl","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"contourcarpet":[{"type":"contourcarpet","colorbar":{"outlinewidth":0,"ticks":""}}],"contour":[{"type":"contour","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"surface":[{"type":"surface","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"mesh3d":[{"type":"mesh3d","colorbar":{"outlinewidth":0,"ticks":""}}],"scatter":[{"fillpattern":{"fillmode":"overlay","size":10,"solidity":0.2},"type":"scatter"}],"parcoords":[{"type":"parcoords","line":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scatterpolargl":[{"type":"scatterpolargl","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"bar":[{"error_x":{"color":"#2a3f5f"},"error_y":{"color":"#2a3f5f"},"marker":{"line":{"color":"#E5ECF6","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"bar"}],"scattergeo":[{"type":"scattergeo","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scatterpolar":[{"type":"scatterpolar","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"histogram":[{"marker":{"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"histogram"}],"scattergl":[{"type":"scattergl","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scatter3d":[{"type":"scatter3d","line":{"colorbar":{"outlinewidth":0,"ticks":""}},"marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scattermapbox":[{"type":"scattermapbox","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scatterternary":[{"type":"scatterternary","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scattercarpet":[{"type":"scattercarpet","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"carpet":[{"aaxis":{"endlinecolor":"#2a3f5f","gridcolor":"white","linecolor":"white","minorgridcolor":"white","startlinecolor":"#2a3f5f"},"baxis":{"endlinecolor":"#2a3f5f","gridcolor":"white","linecolor":"white","minorgridcolor":"white","startlinecolor":"#2a3f5f"},"type":"carpet"}],"table":[{"cells":{"fill":{"color":"#EBF0F8"},"line":{"color":"white"}},"header":{"fill":{"color":"#C8D4E3"},"line":{"color":"white"}},"type":"table"}],"barpolar":[{"marker":{"line":{"color":"#E5ECF6","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"barpolar"}],"pie":[{"automargin":true,"type":"pie"}]},"layout":{"autotypenumbers":"strict","colorway":["#636efa","#EF553B","#00cc96","#ab63fa","#FFA15A","#19d3f3","#FF6692","#B6E880","#FF97FF","#FECB52"],"font":{"color":"#2a3f5f"},"hovermode":"closest","hoverlabel":{"align":"left"},"paper_bgcolor":"white","plot_bgcolor":"#E5ECF6","polar":{"bgcolor":"#E5ECF6","angularaxis":{"gridcolor":"white","linecolor":"white","ticks":""},"radialaxis":{"gridcolor":"white","linecolor":"white","ticks":""}},"ternary":{"bgcolor":"#E5ECF6","aaxis":{"gridcolor":"white","linecolor":"white","ticks":""},"baxis":{"gridcolor":"white","linecolor":"white","ticks":""},"caxis":{"gridcolor":"white","linecolor":"white","ticks":""}},"coloraxis":{"colorbar":{"outlinewidth":0,"ticks":""}},"colorscale":{"sequential":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]],"sequentialminus":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]],"diverging":[[0,"#8e0152"],[0.1,"#c51b7d"],[0.2,"#de77ae"],[0.3,"#f1b6da"],[0.4,"#fde0ef"],[0.5,"#f7f7f7"],[0.6,"#e6f5d0"],[0.7,"#b8e186"],[0.8,"#7fbc41"],[0.9,"#4d9221"],[1,"#276419"]]},"xaxis":{"gridcolor":"white","linecolor":"white","ticks":"","title":{"standoff":15},"zerolinecolor":"white","automargin":true,"zerolinewidth":2},"yaxis":{"gridcolor":"white","linecolor":"white","ticks":"","title":{"standoff":15},"zerolinecolor":"white","automargin":true,"zerolinewidth":2},"scene":{"xaxis":{"backgroundcolor":"#E5ECF6","gridcolor":"white","linecolor":"white","showbackground":true,"ticks":"","zerolinecolor":"white","gridwidth":2},"yaxis":{"backgroundcolor":"#E5ECF6","gridcolor":"white","linecolor":"white","showbackground":true,"ticks":"","zerolinecolor":"white","gridwidth":2},"zaxis":{"backgroundcolor":"#E5ECF6","gridcolor":"white","linecolor":"white","showbackground":true,"ticks":"","zerolinecolor":"white","gridwidth":2}},"shapedefaults":{"line":{"color":"#2a3f5f"}},"annotationdefaults":{"arrowcolor":"#2a3f5f","arrowhead":0,"arrowwidth":1},"geo":{"bgcolor":"white","landcolor":"#E5ECF6","subunitcolor":"white","showland":true,"showlakes":true,"lakecolor":"white"},"title":{"x":0.05},"mapbox":{"style":"light"}}},"coloraxis":{"colorbar":{"title":{"text":"fitness"}},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]},"legend":{"tracegroupgap":0},"margin":{"t":60}},                        {"responsive": true}                    ).then(function(){
                            
var gd = document.getElementById('c5c2c674-3592-4caf-80cf-9d720f73af68');
var x = new MutationObserver(function (mutations, observer) {{
        var display = window.getComputedStyle(gd).display;
        if (!display || display === 'none') {{
            console.log([gd, 'removed!']);
            Plotly.purge(gd);
            observer.disconnect();
        }}
}});

// Listen for the removal of the full notebook cells
var notebookContainer = gd.closest('#notebook-container');
if (notebookContainer) {{
    x.observe(notebookContainer, {childList: true});
}}

// Listen for the clearing of the current output cell
var outputEl = gd.closest('.output');
if (outputEl) {{
    x.observe(outputEl, {childList: true});
}}

                        })                };                });            </script>        </div>
</div>
</div>
<p>To verify some results, I ran a hyper parameter search. I fixed the mutation probability and delta for this experiment, but in hindsight I should run it to include those.</p>
<p>From the figure, if you select only the lowest losses, it becomes clear that most of the hyper parameters do not significantly impact the outcome. Going down, we first see that the addition/deletion probability starts to fade, with only the fewer values returning low losses. After that, the <code>sample_top_n</code>=0 is dropped, meaning that some sampling of the top candidates does improve results.</p>
<p>It is interesting to see that the number of polygons doesn’t seem to have a big impact, and it’s strange to see <code>copy_top_perc</code> not have much impact while the <code>sample_top_n</code> does. They should represent some level of similarity in their results.</p>
</section>
</section>
<section id="future-improvements" class="level3">
<h3 class="anchored" data-anchor-id="future-improvements">Future improvements</h3>
<p>For the pixel approach, a more balanced approach between crossover and mutation seems appropriate. It’s clear the algorithm quickly descents to a point where only mutations seems to be carrying improvements. Tuning the ratios to have a healthier balance with crossover would hopefully result in a slower but longer and more persistent decline of the loss.</p>
<p>For the polygon approach, I think one possible improvement is to have polygons that work on different scales. This means that we would have some polygons that work on large areas and other on small areas and we restrict the number in both or fix them to some proportion. That might allow the algorithm to fill in some finer details while also filling the big areas.</p>
<p>Additionally, the same improvement for the polygons might have to be made as for the pixels. The polygons also quickly seemed to descent into a situation where all individuals are very similar, hence more and stickier crossing over would be good.</p>
<p>Lastly, functionality that allows the addition and deletion of polygon points might bring an interesting variation. This could support pentagons, hexagons and more.</p>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>In this post I showed two approaches that can replicate an image given some target using genetic algorithms. Both approaches have some advantages and some drawbacks, but both have their use. While this example is mainly for academic purposes, the core genetic algorithm has many applications and this practice both improves understanding and awareness of it.</p>
<p>Personally, I’ve really enjoyed working on this project with both the academic understanding as well as the engineering of it being sometimes challenging. I hope you, the reader, has learned something from this post and can use it in your own work.</p>


<!-- -->

</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb12" data-shortcodes="false"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb12-1"><a href="#cb12-1"></a><span class="co">---</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="an">author:</span><span class="co"> Bauke Brenninkmeijer</span></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="an">badges:</span><span class="co"> true</span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="an">branch:</span><span class="co"> master</span></span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="an">categories:</span></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="co">- Genetic Algorithms</span></span>
<span id="cb12-7"><a href="#cb12-7"></a><span class="co">- Machine learning</span></span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="an">date:</span><span class="co"> '2023-02-16'</span></span>
<span id="cb12-9"><a href="#cb12-9"></a><span class="an">image:</span><span class="co"> images/genetic-algorithms/banner.png</span></span>
<span id="cb12-10"><a href="#cb12-10"></a><span class="an">title:</span><span class="co"> Genetic Algorithms for image reconstruction 🧬</span></span>
<span id="cb12-11"><a href="#cb12-11"></a><span class="an">description:</span><span class="co"> How we can leverage genetic algorithms to help with image reconstruction.</span></span>
<span id="cb12-12"><a href="#cb12-12"></a><span class="an">toc:</span><span class="co"> true</span></span>
<span id="cb12-13"><a href="#cb12-13"></a><span class="an">format:</span></span>
<span id="cb12-14"><a href="#cb12-14"></a><span class="co">  html:</span></span>
<span id="cb12-15"><a href="#cb12-15"></a><span class="co">    # code-fold: show</span></span>
<span id="cb12-16"><a href="#cb12-16"></a><span class="co">    code-tools: true</span></span>
<span id="cb12-17"><a href="#cb12-17"></a><span class="co">    # highlight-style: github</span></span>
<span id="cb12-18"><a href="#cb12-18"></a><span class="co">    code-line-numbers: true</span></span>
<span id="cb12-19"><a href="#cb12-19"></a><span class="co">    code-overflow: scroll</span></span>
<span id="cb12-20"><a href="#cb12-20"></a><span class="co">    code-block-border-left: true</span></span>
<span id="cb12-21"><a href="#cb12-21"></a><span class="co">    code-block-bg: true</span></span>
<span id="cb12-22"><a href="#cb12-22"></a><span class="co">    code-copy: true</span></span>
<span id="cb12-23"><a href="#cb12-23"></a><span class="co">---</span></span>
<span id="cb12-24"><a href="#cb12-24"></a></span>
<span id="cb12-25"><a href="#cb12-25"></a>:::{.callout-tip}</span>
<span id="cb12-26"><a href="#cb12-26"></a>All code for this project can be found my <span class="co">[</span><span class="ot">github page</span><span class="co">](https://github.com/Baukebrenninkmeijer/genetic-algorithms)</span></span>
<span id="cb12-27"><a href="#cb12-27"></a>:::</span>
<span id="cb12-28"><a href="#cb12-28"></a></span>
<span id="cb12-29"><a href="#cb12-29"></a></span>
<span id="cb12-30"><a href="#cb12-30"></a><span class="fu">## Introduction</span></span>
<span id="cb12-31"><a href="#cb12-31"></a></span>
<span id="cb12-32"><a href="#cb12-32"></a><span class="al">![Best individual, target and two loss metrics](images/genetic-algorithms/4dots_final_state.png)</span>{#fig-4dots-endstate}</span>
<span id="cb12-33"><a href="#cb12-33"></a></span>
<span id="cb12-34"><a href="#cb12-34"></a>Genetic algorithms are a beautiful subset in the machine learning domain, that use evolutionairy techniques to arrive to solutions that other algorithms have trouble at. These techniques include the combining of solutions, often called crossover, and the slightly altering of solutions, called mutations.</span>
<span id="cb12-35"><a href="#cb12-35"></a></span>
<span id="cb12-36"><a href="#cb12-36"></a>In this post, I'll show two versions genetic algorithms that can be used for image reconstruction given a target image. In the real world, it will have few applications but it's a great theoretical exercise and practice for understanding of the algorithms and image manipulation. However, they are unmistakingly usefull and have been applied in many domains, one being Neural Architecture Search, a method to find the best architecture for a neural network given a specific problem.</span>
<span id="cb12-37"><a href="#cb12-37"></a></span>
<span id="cb12-38"><a href="#cb12-38"></a>While other optimization methods, such a gradient descent, are incredibly powerful for problems that provide a smooth non-stochastic optimization curve, they frequently lack the variance needed for problems with solutions not easily findable following a single trajectory in parameter space. This is where genetic algorithms can provide unexpected solutions.</span>
<span id="cb12-39"><a href="#cb12-39"></a></span>
<span id="cb12-40"><a href="#cb12-40"></a>As in nature, genetic algorithms are based on natural selection and survival of the fittest. That means that each iteration, we select the best candidates for the problem at hand and continue with those. Each individual represents a solutions, and by slightly altering and combining solutions we hope to come to a better solution each iteration. As you can understand, this is a very generic approach that can be applied to all types of problems.</span>
<span id="cb12-41"><a href="#cb12-41"></a></span>
<span id="cb12-42"><a href="#cb12-42"></a><span class="fu">### The algorithm</span></span>
<span id="cb12-43"><a href="#cb12-43"></a></span>
<span id="cb12-44"><a href="#cb12-44"></a>Generally, the algorithms for genetic algorithms follows roughly the same outline and is as follows:</span>
<span id="cb12-45"><a href="#cb12-45"></a></span>
<span id="cb12-46"><a href="#cb12-46"></a><span class="in">```</span></span>
<span id="cb12-47"><a href="#cb12-47"></a><span class="in">pop = create initial popluation with n individuals</span></span>
<span id="cb12-48"><a href="#cb12-48"></a></span>
<span id="cb12-49"><a href="#cb12-49"></a><span class="in">for i in n_iterations:</span></span>
<span id="cb12-50"><a href="#cb12-50"></a><span class="in">    1. randomly combine/reproduce individuals</span></span>
<span id="cb12-51"><a href="#cb12-51"></a><span class="in">    2. randomly mutate individuals</span></span>
<span id="cb12-52"><a href="#cb12-52"></a><span class="in">    3. retain fittest individuals</span></span>
<span id="cb12-53"><a href="#cb12-53"></a><span class="in">```</span></span>
<span id="cb12-54"><a href="#cb12-54"></a></span>
<span id="cb12-55"><a href="#cb12-55"></a></span>
<span id="cb12-56"><a href="#cb12-56"></a><span class="fu">### Mutations</span></span>
<span id="cb12-57"><a href="#cb12-57"></a>Let's start with the most simple version of changes made to candidates: mutations. In any organism with DNA (or some form of it), we see mutations; slight changes in the genetic code. In organism, it's typically the results of an incorrect copy of DNA code, but in this case we are intentionally applying mutation to create slight variations.</span>
<span id="cb12-58"><a href="#cb12-58"></a></span>
<span id="cb12-59"><a href="#cb12-59"></a>For human cells, a mutated cell can start to misbehave, which is generally cleaned up by our immune system. However, sometimes they're missed or not easy to clean up and can lead to serious consequences such as cancer. We also know mutations from sci-fi and monster stories, which result in zombies and the like, but that's unfortunately not what we are talking about today.</span>
<span id="cb12-60"><a href="#cb12-60"></a></span>
<span id="cb12-61"><a href="#cb12-61"></a><span class="fu">### Procreation</span></span>
<span id="cb12-62"><a href="#cb12-62"></a>Procreation is very important for this algorithm, because it allows the combining of two (or more) individuals into a new individual. Hopefully, this leads to to an individual that has all good qualities of their parents and none of the bad. In the rest of this post, the terms procreation, crossover and combine are used interchangeably for this concept.</span>
<span id="cb12-63"><a href="#cb12-63"></a></span>
<span id="cb12-64"><a href="#cb12-64"></a>An example with two individuals and their crossover. In this example, and individual is defined by its genes: 4 binary digits. The crossover in this case is just taking the first two digits of the first individual and the latter two of the second individual.</span>
<span id="cb12-65"><a href="#cb12-65"></a></span>
<span id="cb12-68"><a href="#cb12-68"></a><span class="in">```{python}</span></span>
<span id="cb12-69"><a href="#cb12-69"></a>ind1 <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb12-70"><a href="#cb12-70"></a>ind2 <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>]</span>
<span id="cb12-71"><a href="#cb12-71"></a></span>
<span id="cb12-72"><a href="#cb12-72"></a><span class="kw">def</span> crossover(a, b):</span>
<span id="cb12-73"><a href="#cb12-73"></a>  <span class="cf">return</span> a[:<span class="dv">2</span>] <span class="op">+</span> b[<span class="dv">2</span>:]</span>
<span id="cb12-74"><a href="#cb12-74"></a></span>
<span id="cb12-75"><a href="#cb12-75"></a><span class="bu">print</span>(<span class="ss">f'Result of crossover: </span><span class="sc">{</span>crossover(ind1, ind2)<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb12-76"><a href="#cb12-76"></a><span class="in">```</span></span>
<span id="cb12-77"><a href="#cb12-77"></a></span>
<span id="cb12-78"><a href="#cb12-78"></a><span class="fu">### Fitness function</span></span>
<span id="cb12-79"><a href="#cb12-79"></a>To assess which individuals are the most fit, you need some metric. Depending on the problem, naturally you can use many different versions. In our case, image reconstruction, we are going to use the mean-squared error of the pixel values $l = \frac{1}{n} \sum_{i=1}^{n}(c_i - T)^2$ where $n$ is the size of the population, $c_i$ is candidate $i$ and $T$ the target image. This works nicely with our data and as always, penalizes the largest errors the most.</span>
<span id="cb12-80"><a href="#cb12-80"></a></span>
<span id="cb12-81"><a href="#cb12-81"></a><span class="fu">## Pixelwise</span></span>
<span id="cb12-82"><a href="#cb12-82"></a>In this method, we try to recreate the target image by manipulating individual pixels and comibing whole pixel arrays. The genes of an individual is a pixel array the size of the target image. For some RGB image, this will be a three dimensional, for example (200, 200, 3).</span>
<span id="cb12-83"><a href="#cb12-83"></a></span>
<span id="cb12-84"><a href="#cb12-84"></a>Let's first deine a pixel individual and set its genes to the shape that we want. We also give an option to pass genes, which is handy for the crossover step later. Lastly, we define that probability to mutate <span class="in">`mutate_p`</span> and the delta of a mutation <span class="in">`mutate_d`</span>. The main methods of the individual are already defined here as well.</span>
<span id="cb12-85"><a href="#cb12-85"></a></span>
<span id="cb12-88"><a href="#cb12-88"></a><span class="in">```{python}</span></span>
<span id="cb12-89"><a href="#cb12-89"></a><span class="co">#| echo: false</span></span>
<span id="cb12-90"><a href="#cb12-90"></a></span>
<span id="cb12-91"><a href="#cb12-91"></a><span class="im">from</span> __future__ <span class="im">import</span> annotations</span>
<span id="cb12-92"><a href="#cb12-92"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb12-93"><a href="#cb12-93"></a><span class="im">from</span> typing <span class="im">import</span> Tuple</span>
<span id="cb12-94"><a href="#cb12-94"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb12-95"><a href="#cb12-95"></a></span>
<span id="cb12-96"><a href="#cb12-96"></a><span class="kw">class</span> PixelIndividual:</span>
<span id="cb12-97"><a href="#cb12-97"></a>    <span class="co">"""Individual with pixel grid for genes."""</span></span>
<span id="cb12-98"><a href="#cb12-98"></a></span>
<span id="cb12-99"><a href="#cb12-99"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(</span>
<span id="cb12-100"><a href="#cb12-100"></a>        <span class="va">self</span>,</span>
<span id="cb12-101"><a href="#cb12-101"></a>        shape: Tuple,</span>
<span id="cb12-102"><a href="#cb12-102"></a>        genes: np.ndarray <span class="op">|</span> <span class="va">None</span> <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb12-103"><a href="#cb12-103"></a>        mutate_d: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.05</span>,</span>
<span id="cb12-104"><a href="#cb12-104"></a>        mutate_p: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.2</span>,</span>
<span id="cb12-105"><a href="#cb12-105"></a>    ):</span>
<span id="cb12-106"><a href="#cb12-106"></a>        <span class="cf">assert</span> <span class="dv">0</span> <span class="op">&lt;=</span> mutate_d <span class="op">&lt;=</span> <span class="dv">1</span></span>
<span id="cb12-107"><a href="#cb12-107"></a>        <span class="cf">assert</span> <span class="dv">0</span> <span class="op">&lt;=</span> mutate_p <span class="op">&lt;=</span> <span class="dv">1</span></span>
<span id="cb12-108"><a href="#cb12-108"></a>        <span class="va">self</span>.shape <span class="op">=</span> shape</span>
<span id="cb12-109"><a href="#cb12-109"></a>        <span class="va">self</span>.mutate_d <span class="op">=</span> mutate_d</span>
<span id="cb12-110"><a href="#cb12-110"></a>        <span class="va">self</span>.mutate_p <span class="op">=</span> mutate_p</span>
<span id="cb12-111"><a href="#cb12-111"></a>        <span class="cf">if</span> genes <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb12-112"><a href="#cb12-112"></a>            <span class="va">self</span>.genes <span class="op">=</span> (np.random.rand(<span class="op">*</span>shape)).astype(np.float32)</span>
<span id="cb12-113"><a href="#cb12-113"></a>        <span class="cf">else</span>:</span>
<span id="cb12-114"><a href="#cb12-114"></a>            <span class="va">self</span>.genes <span class="op">=</span> genes</span>
<span id="cb12-115"><a href="#cb12-115"></a></span>
<span id="cb12-116"><a href="#cb12-116"></a>    <span class="kw">def</span> show(<span class="va">self</span>):</span>
<span id="cb12-117"><a href="#cb12-117"></a>        plt.imshow(<span class="va">self</span>.genes)</span>
<span id="cb12-118"><a href="#cb12-118"></a>        plt.show()</span>
<span id="cb12-119"><a href="#cb12-119"></a></span>
<span id="cb12-120"><a href="#cb12-120"></a>    <span class="kw">def</span> crossover(<span class="va">self</span>, other: PixelIndividual) <span class="op">-&gt;</span> PixelIndividual:</span>
<span id="cb12-121"><a href="#cb12-121"></a>        <span class="bu">filter</span> <span class="op">=</span> np.random.randint(low<span class="op">=</span><span class="dv">0</span>, high<span class="op">=</span><span class="dv">2</span>, size<span class="op">=</span><span class="va">self</span>.genes.shape)</span>
<span id="cb12-122"><a href="#cb12-122"></a>        output <span class="op">=</span> np.where(<span class="bu">filter</span>, <span class="va">self</span>.genes, other.genes)</span>
<span id="cb12-123"><a href="#cb12-123"></a>        <span class="cf">return</span> PixelIndividual(shape<span class="op">=</span><span class="va">self</span>.shape, genes<span class="op">=</span>output)</span>
<span id="cb12-124"><a href="#cb12-124"></a>        <span class="cf">return</span> PixelIndividual(shape<span class="op">=</span><span class="va">self</span>.shape, genes<span class="op">=</span>np.mean([<span class="va">self</span>.genes, other.genes], axis<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb12-125"><a href="#cb12-125"></a></span>
<span id="cb12-126"><a href="#cb12-126"></a>    <span class="kw">def</span> mutate(<span class="va">self</span>):</span>
<span id="cb12-127"><a href="#cb12-127"></a>        <span class="cf">if</span> <span class="va">self</span>.mutate_p <span class="op">&gt;</span> np.random.rand():</span>
<span id="cb12-128"><a href="#cb12-128"></a>            <span class="va">self</span>.mutation <span class="op">=</span> (</span>
<span id="cb12-129"><a href="#cb12-129"></a>                (np.random.rand(<span class="op">*</span><span class="va">self</span>.shape) <span class="op">*</span> <span class="va">self</span>.mutate_d) <span class="op">-</span> (<span class="va">self</span>.mutate_d <span class="op">*</span> <span class="fl">0.5</span>)).astype(np.float32)</span>
<span id="cb12-130"><a href="#cb12-130"></a>            <span class="va">self</span>.genes <span class="op">=</span> np.clip(<span class="va">self</span>.genes <span class="op">+</span> <span class="va">self</span>.mutation, a_min<span class="op">=</span><span class="fl">0.0</span>, a_max<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb12-131"><a href="#cb12-131"></a></span>
<span id="cb12-132"><a href="#cb12-132"></a>    <span class="kw">def</span> compute_fitness(<span class="va">self</span>, target: np.ndarray):</span>
<span id="cb12-133"><a href="#cb12-133"></a>        <span class="cf">assert</span> <span class="va">self</span>.genes.dtype.name <span class="op">==</span> <span class="st">'float32'</span>, <span class="ss">f'genes dtype should be float32 but found </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>genes<span class="sc">.</span>dtype<span class="sc">.</span>name<span class="sc">}</span><span class="ss">.'</span></span>
<span id="cb12-134"><a href="#cb12-134"></a>        <span class="va">self</span>.fitness <span class="op">=</span> ((<span class="va">self</span>.genes <span class="op">-</span> target) <span class="op">**</span> <span class="dv">2</span>).mean()</span>
<span id="cb12-135"><a href="#cb12-135"></a></span>
<span id="cb12-136"><a href="#cb12-136"></a>    <span class="kw">def</span> copy(<span class="va">self</span>) <span class="op">-&gt;</span> PixelIndividual:</span>
<span id="cb12-137"><a href="#cb12-137"></a>        <span class="cf">return</span> PixelIndividual(shape<span class="op">=</span><span class="va">self</span>.shape, genes<span class="op">=</span><span class="va">self</span>.genes)</span>
<span id="cb12-138"><a href="#cb12-138"></a></span>
<span id="cb12-139"><a href="#cb12-139"></a>    <span class="kw">def</span> get_image(<span class="va">self</span>) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="cb12-140"><a href="#cb12-140"></a>        <span class="cf">return</span> <span class="va">self</span>.genes</span>
<span id="cb12-141"><a href="#cb12-141"></a></span>
<span id="cb12-142"><a href="#cb12-142"></a>    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):</span>
<span id="cb12-143"><a href="#cb12-143"></a>        <span class="cf">return</span> <span class="ss">f'</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>__class__<span class="sc">.</span><span class="va">__name__</span><span class="sc">}</span><span class="ss">(shape=</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>shape<span class="sc">}</span><span class="ss">, fitness=</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>fitness<span class="sc">:.4f}</span><span class="ss">)'</span></span>
<span id="cb12-144"><a href="#cb12-144"></a></span>
<span id="cb12-145"><a href="#cb12-145"></a><span class="in">```</span></span>
<span id="cb12-146"><a href="#cb12-146"></a></span>
<span id="cb12-147"><a href="#cb12-147"></a></span>
<span id="cb12-150"><a href="#cb12-150"></a><span class="in">```{python}</span></span>
<span id="cb12-151"><a href="#cb12-151"></a><span class="co">#| column: page</span></span>
<span id="cb12-152"><a href="#cb12-152"></a><span class="co">#| eval: false</span></span>
<span id="cb12-153"><a href="#cb12-153"></a></span>
<span id="cb12-154"><a href="#cb12-154"></a><span class="kw">class</span> PixelIndividual:</span>
<span id="cb12-155"><a href="#cb12-155"></a>    <span class="co">"""Individual with pixel grid for genes."""</span></span>
<span id="cb12-156"><a href="#cb12-156"></a></span>
<span id="cb12-157"><a href="#cb12-157"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(</span>
<span id="cb12-158"><a href="#cb12-158"></a>        <span class="va">self</span>,</span>
<span id="cb12-159"><a href="#cb12-159"></a>        shape: Tuple,</span>
<span id="cb12-160"><a href="#cb12-160"></a>        genes: np.ndarray <span class="op">|</span> <span class="va">None</span> <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb12-161"><a href="#cb12-161"></a>        mutate_d: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.05</span>,</span>
<span id="cb12-162"><a href="#cb12-162"></a>        mutate_p: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb12-163"><a href="#cb12-163"></a>    ):</span>
<span id="cb12-164"><a href="#cb12-164"></a>        <span class="va">self</span>.shape <span class="op">=</span> shape</span>
<span id="cb12-165"><a href="#cb12-165"></a>        <span class="va">self</span>.mutate_d <span class="op">=</span> mutate_d</span>
<span id="cb12-166"><a href="#cb12-166"></a>        <span class="va">self</span>.mutate_p <span class="op">=</span> mutate_p</span>
<span id="cb12-167"><a href="#cb12-167"></a>        <span class="va">self</span>.genes <span class="op">=</span> np.random.rand(<span class="op">*</span>shape).astype(np.float32) <span class="cf">if</span> <span class="kw">not</span> genes <span class="cf">else</span> genes</span>
<span id="cb12-168"><a href="#cb12-168"></a></span>
<span id="cb12-169"><a href="#cb12-169"></a></span>
<span id="cb12-170"><a href="#cb12-170"></a><span class="in">```</span></span>
<span id="cb12-171"><a href="#cb12-171"></a></span>
<span id="cb12-172"><a href="#cb12-172"></a><span class="fu">### Crossover</span></span>
<span id="cb12-173"><a href="#cb12-173"></a></span>
<span id="cb12-174"><a href="#cb12-174"></a>The second method is our choice of what happens during crossover. How to implement a crossover function is really up to the person working on the problem. Initially I just took the pixelwise mean of both parents, but that seemed to always kind of move towards hovering around 0.5, which is maybe logical, but definitely undesirable. In this version, I chose to randomly take each pixel from either parent. This seems to work fairly well but you can use many other versions so make sure to play around with this a bit yourself. The <span class="in">`filter_arr`</span> creates an array of random zeros and ones. We use it as a filter to decide which value to pick.</span>
<span id="cb12-175"><a href="#cb12-175"></a></span>
<span id="cb12-178"><a href="#cb12-178"></a><span class="in">```{python}</span></span>
<span id="cb12-179"><a href="#cb12-179"></a><span class="co">#| column: page</span></span>
<span id="cb12-180"><a href="#cb12-180"></a><span class="co">#| eval: false</span></span>
<span id="cb12-181"><a href="#cb12-181"></a></span>
<span id="cb12-182"><a href="#cb12-182"></a> <span class="kw">def</span> crossover(<span class="va">self</span>, other: PixelIndividual) <span class="op">-&gt;</span> PixelIndividual:</span>
<span id="cb12-183"><a href="#cb12-183"></a>        filter_arr <span class="op">=</span> np.random.randint(low<span class="op">=</span><span class="dv">0</span>, high<span class="op">=</span><span class="dv">2</span>, size<span class="op">=</span><span class="va">self</span>.genes.shape)</span>
<span id="cb12-184"><a href="#cb12-184"></a>        output <span class="op">=</span> np.where(filter_arr, <span class="va">self</span>.genes, other.genes)</span>
<span id="cb12-185"><a href="#cb12-185"></a>        <span class="cf">return</span> PixelIndividual(shape<span class="op">=</span><span class="va">self</span>.shape, genes<span class="op">=</span>output)</span>
<span id="cb12-186"><a href="#cb12-186"></a><span class="in">```</span></span>
<span id="cb12-187"><a href="#cb12-187"></a></span>
<span id="cb12-188"><a href="#cb12-188"></a><span class="fu">### Mutation</span></span>
<span id="cb12-189"><a href="#cb12-189"></a>Then, onto the mutation part. We create some noise of a certain magnitude, shift it so the mean is zero and half of it is negative and add it to the existing pixel values of said candidate. In the plot below you can see the distribution of a mutation for an individual with 100x100 grid as genes. I have chosen a uniform distribution for this, but again, you can choose others such as normal. However, the domain of the uniform distribution is simple and intuitive. For example, scaling an uniform distribution with 0.2 will have a magnitude of 0.2 as well, ranging from 0 to 0.2 distributed evenly. So you can see why working with this distribution is nice.</span>
<span id="cb12-190"><a href="#cb12-190"></a></span>
<span id="cb12-193"><a href="#cb12-193"></a><span class="in">```{python}</span></span>
<span id="cb12-194"><a href="#cb12-194"></a><span class="co">#| echo: false</span></span>
<span id="cb12-195"><a href="#cb12-195"></a><span class="co">#| output: freeze</span></span>
<span id="cb12-196"><a href="#cb12-196"></a></span>
<span id="cb12-197"><a href="#cb12-197"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb12-198"><a href="#cb12-198"></a>ind <span class="op">=</span> PixelIndividual(shape<span class="op">=</span>(<span class="dv">100</span>, <span class="dv">100</span>), mutate_p<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb12-199"><a href="#cb12-199"></a>ind.mutate()</span>
<span id="cb12-200"><a href="#cb12-200"></a>sns.histplot(ind.mutation.reshape(<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb12-201"><a href="#cb12-201"></a>plt.title(<span class="st">'Histogram of the mutation values'</span>)</span>
<span id="cb12-202"><a href="#cb12-202"></a>plt.ylabel(<span class="st">'Count of bin values'</span>)</span>
<span id="cb12-203"><a href="#cb12-203"></a>plt.xlabel(<span class="st">'Mutation value'</span>)</span>
<span id="cb12-204"><a href="#cb12-204"></a>plt.show()</span>
<span id="cb12-205"><a href="#cb12-205"></a><span class="in">```</span></span>
<span id="cb12-206"><a href="#cb12-206"></a></span>
<span id="cb12-207"><a href="#cb12-207"></a>As a last step, we apply the mutation and clip the values to the range <span class="co">[</span><span class="ot">0, 1</span><span class="co">]</span>. This is because otherwise we can mutate outside of the colour boundaries of an image, which will be clipped when shown as an image anyway. The domain for pixel values with a float is <span class="co">[</span><span class="ot">0, 1</span><span class="co">]</span> or <span class="co">[</span><span class="ot">0, 255</span><span class="co">]</span> for integer values, and plotting libraries like matplotlib will clip values for you if you don't. To prevent hidden problems, we already make sure the domains and datatypes are correct.</span>
<span id="cb12-208"><a href="#cb12-208"></a></span>
<span id="cb12-211"><a href="#cb12-211"></a><span class="in">```{python}</span></span>
<span id="cb12-212"><a href="#cb12-212"></a><span class="co">#| column: page</span></span>
<span id="cb12-213"><a href="#cb12-213"></a><span class="co">#| eval: false</span></span>
<span id="cb12-214"><a href="#cb12-214"></a></span>
<span id="cb12-215"><a href="#cb12-215"></a>    <span class="kw">def</span> mutate(<span class="va">self</span>):</span>
<span id="cb12-216"><a href="#cb12-216"></a>        <span class="cf">if</span> <span class="va">self</span>.mutate_p <span class="op">&gt;</span> np.random.rand():</span>
<span id="cb12-217"><a href="#cb12-217"></a>            <span class="va">self</span>.mutation <span class="op">=</span> (np.random.rand(<span class="op">*</span><span class="va">self</span>.shape) <span class="op">*</span> <span class="va">self</span>.mutate_d) <span class="op">-</span> (<span class="va">self</span>.mutate_d <span class="op">*</span> <span class="fl">0.5</span>)</span>
<span id="cb12-218"><a href="#cb12-218"></a>            <span class="va">self</span>.mutation <span class="op">=</span> <span class="va">self</span>.mutation.astype(np.float32)</span>
<span id="cb12-219"><a href="#cb12-219"></a>            <span class="va">self</span>.genes <span class="op">=</span> np.clip(<span class="va">self</span>.genes <span class="op">+</span> <span class="va">self</span>.mutation, a_min<span class="op">=</span><span class="fl">0.0</span>, a_max<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb12-220"><a href="#cb12-220"></a></span>
<span id="cb12-221"><a href="#cb12-221"></a><span class="in">```</span></span>
<span id="cb12-222"><a href="#cb12-222"></a></span>
<span id="cb12-223"><a href="#cb12-223"></a>Because I encountered a lot of datatype issues, such as float64 and integer reprentations, I cast most computation to float32 and also do a dtype check in the <span class="in">`compute_fitness`</span> method. This is because this is the last step of each iteration, and generally should represent if things went correctly.</span>
<span id="cb12-224"><a href="#cb12-224"></a></span>
<span id="cb12-225"><a href="#cb12-225"></a>The fitness method is in this case the mean-squared error.</span>
<span id="cb12-226"><a href="#cb12-226"></a></span>
<span id="cb12-229"><a href="#cb12-229"></a><span class="in">```{python}</span></span>
<span id="cb12-230"><a href="#cb12-230"></a><span class="co">#| column: page</span></span>
<span id="cb12-231"><a href="#cb12-231"></a><span class="co">#| eval: false</span></span>
<span id="cb12-232"><a href="#cb12-232"></a></span>
<span id="cb12-233"><a href="#cb12-233"></a></span>
<span id="cb12-234"><a href="#cb12-234"></a>    <span class="kw">def</span> compute_fitness(<span class="va">self</span>, target: np.ndarray):</span>
<span id="cb12-235"><a href="#cb12-235"></a>        <span class="cf">assert</span> <span class="va">self</span>.genes.dtype.name <span class="op">==</span> <span class="st">'float32'</span>, (</span>
<span id="cb12-236"><a href="#cb12-236"></a>            <span class="ss">f'genes dtype should be float32 but found </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>genes<span class="sc">.</span>dtype<span class="sc">.</span>name<span class="sc">}</span><span class="ss">.'</span></span>
<span id="cb12-237"><a href="#cb12-237"></a>        )</span>
<span id="cb12-238"><a href="#cb12-238"></a>        <span class="va">self</span>.fitness <span class="op">=</span> ((<span class="va">self</span>.genes <span class="op">-</span> target) <span class="op">**</span> <span class="dv">2</span>).mean()</span>
<span id="cb12-239"><a href="#cb12-239"></a><span class="in">```</span></span>
<span id="cb12-240"><a href="#cb12-240"></a></span>
<span id="cb12-241"><a href="#cb12-241"></a><span class="fu">### Results</span></span>
<span id="cb12-242"><a href="#cb12-242"></a></span>
<span id="cb12-243"><a href="#cb12-243"></a>Some of the results are pretty cool. With smaller images, it works quite fast but for larger it can take several hours to several days to get any good results. The mario image took around 12 hours to create, and while you can clearly see the outlines, it's far from perfect.</span>
<span id="cb12-244"><a href="#cb12-244"></a></span>
<span id="cb12-245"><a href="#cb12-245"></a><span class="fu">#### Toy example: 10x10 matrix</span></span>
<span id="cb12-246"><a href="#cb12-246"></a></span>
<span id="cb12-247"><a href="#cb12-247"></a>This run is for just 200 iterations and takes around a minute. The right most graph shows the fitness distribution of the current population. The fitness function here was sum of squared errors, rather than mean.</span>
<span id="cb12-248"><a href="#cb12-248"></a></span>
<span id="cb12-249"><a href="#cb12-249"></a><span class="al">![Best individual, target and two loss metrics of a 10x10 pixel grid with 4 dots](images/genetic-algorithms/4dots_training.gif)</span>{#fig-4dots-training .column-screen}</span>
<span id="cb12-250"><a href="#cb12-250"></a></span>
<span id="cb12-251"><a href="#cb12-251"></a></span>
<span id="cb12-252"><a href="#cb12-252"></a><span class="fu">#### Slightly less toy example: 100x100 matrix with gradient</span></span>
<span id="cb12-253"><a href="#cb12-253"></a></span>
<span id="cb12-254"><a href="#cb12-254"></a>This run is for 10k iterations and takes around a 1-2 hours. The right most graph shows the fitness distribution of the current population. You can see the graph struggle to show a clear distribution. This seems to mean that the whole distribution is very close, although the values on the x-axis are pretty big, so I'm not entirely sure why it cannot show a good distribution.</span>
<span id="cb12-255"><a href="#cb12-255"></a></span>
<span id="cb12-256"><a href="#cb12-256"></a>You can see an immediate steep decline in loss, which is attributed to the initial high variety in individuals. The further the iterations go, the more we have selected the optimal individuals and the more of the population can be considered brothers and sisters of the original best individual. When the problem is complex and high-dimensional, this happens more and more, since it's quite unlikely that other candidates can present a better solution from mutation within the timeframe of the best candidate taking over the population.</span>
<span id="cb12-257"><a href="#cb12-257"></a></span>
<span id="cb12-258"><a href="#cb12-258"></a><span class="al">![Best individual, target and two loss metrics of a 100x100 pixel grid with gradient](images/genetic-algorithms/gradient_training_optimized_compressed.gif)</span>{#fig-gradient-training .column-screen}</span>
<span id="cb12-259"><a href="#cb12-259"></a></span>
<span id="cb12-260"><a href="#cb12-260"></a><span class="fu">#### The real deal</span></span>
<span id="cb12-261"><a href="#cb12-261"></a></span>
<span id="cb12-262"><a href="#cb12-262"></a><span class="al">![Best individual, target and two loss metrics of Mario](images/genetic-algorithms/mario_training_optimized.gif)</span>{#fig-gradient-training .column-screen}</span>
<span id="cb12-263"><a href="#cb12-263"></a></span>
<span id="cb12-264"><a href="#cb12-264"></a><span class="fu">## Polygons</span></span>
<span id="cb12-265"><a href="#cb12-265"></a></span>
<span id="cb12-266"><a href="#cb12-266"></a>The second method of approximating images is using a population of polygons. Polygons are shapes with 3 or more points connected in no specific order. This could be a triangle, square but also also an hourglass shape has 4 points where the middle lines cross. While we could randomly add or remove points, in this case I chose to leave it at 3 points.</span>
<span id="cb12-267"><a href="#cb12-267"></a></span>
<span id="cb12-268"><a href="#cb12-268"></a><span class="fu">### Individuals</span></span>
<span id="cb12-269"><a href="#cb12-269"></a></span>
<span id="cb12-270"><a href="#cb12-270"></a>The individuals here are slightly more complex than the pixel versions. That is because the polygons have their own class. Each individual's genes are composed of a starting amount of 10-20 polygons.</span>
<span id="cb12-271"><a href="#cb12-271"></a></span>
<span id="cb12-272"><a href="#cb12-272"></a><span class="fu">### Crossover</span></span>
<span id="cb12-273"><a href="#cb12-273"></a></span>
<span id="cb12-274"><a href="#cb12-274"></a>Crossovers are done simply by randomly taking a polygon of either parents. If one of the parents has more polygons, we randomly add polygons in those indices as well.</span>
<span id="cb12-275"><a href="#cb12-275"></a></span>
<span id="cb12-278"><a href="#cb12-278"></a><span class="in">```{python}</span></span>
<span id="cb12-279"><a href="#cb12-279"></a><span class="co">#| column: page</span></span>
<span id="cb12-280"><a href="#cb12-280"></a><span class="co">#| eval: false</span></span>
<span id="cb12-281"><a href="#cb12-281"></a></span>
<span id="cb12-282"><a href="#cb12-282"></a><span class="kw">def</span> crossover(<span class="va">self</span>, other):</span>
<span id="cb12-283"><a href="#cb12-283"></a>    child <span class="op">=</span> copy.deepcopy(<span class="va">self</span>)</span>
<span id="cb12-284"><a href="#cb12-284"></a>    <span class="cf">for</span> idx, poly <span class="kw">in</span> <span class="bu">enumerate</span>(other.polygons):</span>
<span id="cb12-285"><a href="#cb12-285"></a>        <span class="cf">if</span> <span class="fl">0.5</span> <span class="op">&lt;</span> np.random.random():</span>
<span id="cb12-286"><a href="#cb12-286"></a>            <span class="cf">try</span>:</span>
<span id="cb12-287"><a href="#cb12-287"></a>                child.polygons[idx] <span class="op">=</span> poly</span>
<span id="cb12-288"><a href="#cb12-288"></a>            <span class="cf">except</span>:</span>
<span id="cb12-289"><a href="#cb12-289"></a>                <span class="co"># When idx is out of range of child.polygons, we append.</span></span>
<span id="cb12-290"><a href="#cb12-290"></a>                child.polygons.append(poly)</span>
<span id="cb12-291"><a href="#cb12-291"></a>    <span class="cf">return</span> child</span>
<span id="cb12-292"><a href="#cb12-292"></a></span>
<span id="cb12-293"><a href="#cb12-293"></a><span class="in">```</span></span>
<span id="cb12-294"><a href="#cb12-294"></a></span>
<span id="cb12-295"><a href="#cb12-295"></a><span class="fu">### Mutation</span></span>
<span id="cb12-296"><a href="#cb12-296"></a></span>
<span id="cb12-297"><a href="#cb12-297"></a><span class="fu">#### Individual</span></span>
<span id="cb12-298"><a href="#cb12-298"></a></span>
<span id="cb12-299"><a href="#cb12-299"></a>Mutation in this case has to be done at the "genes" level rather than the individual level. So the <span class="in">`mutate`</span> method of the individuals here is surpisingly simple.</span>
<span id="cb12-300"><a href="#cb12-300"></a></span>
<span id="cb12-303"><a href="#cb12-303"></a><span class="in">```{python}</span></span>
<span id="cb12-304"><a href="#cb12-304"></a><span class="co">#| column: page</span></span>
<span id="cb12-305"><a href="#cb12-305"></a><span class="co">#| eval: false</span></span>
<span id="cb12-306"><a href="#cb12-306"></a></span>
<span id="cb12-307"><a href="#cb12-307"></a><span class="kw">def</span> mutate(<span class="va">self</span>):</span>
<span id="cb12-308"><a href="#cb12-308"></a>    <span class="co">"""mutate method for an individual"""</span></span>
<span id="cb12-309"><a href="#cb12-309"></a>    <span class="cf">for</span> polygon <span class="kw">in</span> <span class="va">self</span>.polygons:</span>
<span id="cb12-310"><a href="#cb12-310"></a>        polygon.mutate()</span>
<span id="cb12-311"><a href="#cb12-311"></a></span>
<span id="cb12-312"><a href="#cb12-312"></a>    <span class="co"># deletion chance</span></span>
<span id="cb12-313"><a href="#cb12-313"></a>    <span class="cf">if</span> np.random.random() <span class="op">&lt;</span> <span class="va">self</span>.add_or_del_p <span class="kw">and</span> <span class="bu">len</span>(<span class="va">self</span>.polygons) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb12-314"><a href="#cb12-314"></a>        idx <span class="op">=</span> np.random.randint(<span class="dv">0</span>, <span class="bu">len</span>(<span class="va">self</span>.polygons) <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb12-315"><a href="#cb12-315"></a>        <span class="va">self</span>.polygons.pop(idx)</span>
<span id="cb12-316"><a href="#cb12-316"></a></span>
<span id="cb12-317"><a href="#cb12-317"></a>    <span class="co"># addition chance</span></span>
<span id="cb12-318"><a href="#cb12-318"></a>    <span class="cf">if</span> np.random.random() <span class="op">&lt;</span> <span class="va">self</span>.add_or_del_p:</span>
<span id="cb12-319"><a href="#cb12-319"></a>        <span class="va">self</span>.polygons.append(</span>
<span id="cb12-320"><a href="#cb12-320"></a>            Polygon(</span>
<span id="cb12-321"><a href="#cb12-321"></a>                canvas_size<span class="op">=</span><span class="va">self</span>.canvas_size,</span>
<span id="cb12-322"><a href="#cb12-322"></a>                mutate_delta<span class="op">=</span><span class="va">self</span>.mutate_delta,</span>
<span id="cb12-323"><a href="#cb12-323"></a>                mutate_p<span class="op">=</span><span class="va">self</span>.mutate_p,</span>
<span id="cb12-324"><a href="#cb12-324"></a>            )</span>
<span id="cb12-325"><a href="#cb12-325"></a>        )</span>
<span id="cb12-326"><a href="#cb12-326"></a><span class="in">```</span></span>
<span id="cb12-327"><a href="#cb12-327"></a></span>
<span id="cb12-328"><a href="#cb12-328"></a>There are three steps:</span>
<span id="cb12-329"><a href="#cb12-329"></a></span>
<span id="cb12-330"><a href="#cb12-330"></a><span class="ss">1. </span>Mutate each polygon individually (i.e. change the location of the points and the colour)</span>
<span id="cb12-331"><a href="#cb12-331"></a><span class="ss">2. </span>Randomly delete a polygon</span>
<span id="cb12-332"><a href="#cb12-332"></a><span class="ss">3. </span>Randomly add a polygon</span>
<span id="cb12-333"><a href="#cb12-333"></a></span>
<span id="cb12-334"><a href="#cb12-334"></a><span class="fu">#### Genes</span></span>
<span id="cb12-335"><a href="#cb12-335"></a></span>
<span id="cb12-338"><a href="#cb12-338"></a><span class="in">```{python}</span></span>
<span id="cb12-339"><a href="#cb12-339"></a><span class="co">#| column: page</span></span>
<span id="cb12-340"><a href="#cb12-340"></a><span class="co">#| eval: false</span></span>
<span id="cb12-341"><a href="#cb12-341"></a></span>
<span id="cb12-342"><a href="#cb12-342"></a>    <span class="kw">def</span> mutate(<span class="va">self</span>):</span>
<span id="cb12-343"><a href="#cb12-343"></a>        <span class="co">"""mutate method for a gene"""</span></span>
<span id="cb12-344"><a href="#cb12-344"></a>        changed <span class="op">=</span> <span class="va">False</span></span>
<span id="cb12-345"><a href="#cb12-345"></a>        <span class="cf">for</span> coord <span class="kw">in</span> <span class="va">self</span>.coords:</span>
<span id="cb12-346"><a href="#cb12-346"></a>            <span class="cf">if</span> <span class="va">self</span>.mutate_p <span class="op">&gt;</span> np.random.random():</span>
<span id="cb12-347"><a href="#cb12-347"></a>                changed <span class="op">=</span> <span class="va">True</span></span>
<span id="cb12-348"><a href="#cb12-348"></a>                coord[<span class="dv">0</span>] <span class="op">+=</span> np.random.randint(<span class="dv">0</span>, <span class="bu">int</span>(<span class="va">self</span>.x_size <span class="op">*</span> <span class="va">self</span>.mutate_d)) <span class="op">-</span> <span class="bu">int</span>(</span>
<span id="cb12-349"><a href="#cb12-349"></a>                    <span class="va">self</span>.x_size <span class="op">*</span> <span class="va">self</span>.mutate_d <span class="op">*</span> <span class="fl">0.5</span></span>
<span id="cb12-350"><a href="#cb12-350"></a>                )</span>
<span id="cb12-351"><a href="#cb12-351"></a>                coord[<span class="dv">0</span>] <span class="op">=</span> np.clip(coord[<span class="dv">0</span>], <span class="dv">0</span>, <span class="va">self</span>.x_size)</span>
<span id="cb12-352"><a href="#cb12-352"></a>                coord[<span class="dv">1</span>] <span class="op">+=</span> np.random.randint(<span class="dv">0</span>, <span class="bu">int</span>(<span class="va">self</span>.y_size <span class="op">*</span> <span class="va">self</span>.mutate_d)) <span class="op">-</span> <span class="bu">int</span>(<span class="va">self</span>.y_size <span class="op">*</span> <span class="va">self</span>.mutate_d <span class="op">*</span> <span class="fl">0.5</span>)</span>
<span id="cb12-353"><a href="#cb12-353"></a>                coord[<span class="dv">1</span>] <span class="op">=</span> np.clip(coord[<span class="dv">1</span>], <span class="dv">0</span>, <span class="va">self</span>.y_size)</span>
<span id="cb12-354"><a href="#cb12-354"></a></span>
<span id="cb12-355"><a href="#cb12-355"></a>        <span class="cf">if</span> <span class="va">self</span>.mutate_p <span class="op">&gt;</span> np.random.random():</span>
<span id="cb12-356"><a href="#cb12-356"></a>            <span class="va">self</span>.color <span class="op">+=</span> (np.random.random(<span class="va">self</span>.color_c) <span class="op">*</span> <span class="va">self</span>.mutate_d) <span class="op">-</span> (<span class="va">self</span>.mutate_d <span class="op">*</span> <span class="fl">0.5</span>)</span>
<span id="cb12-357"><a href="#cb12-357"></a>            <span class="va">self</span>.color <span class="op">=</span> np.clip(<span class="va">self</span>.color, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb12-358"><a href="#cb12-358"></a></span>
<span id="cb12-359"><a href="#cb12-359"></a>        <span class="cf">if</span> changed:</span>
<span id="cb12-360"><a href="#cb12-360"></a>            <span class="cf">assert</span> (<span class="dv">0</span> <span class="op">&lt;=</span> <span class="va">self</span>.color).<span class="bu">all</span>() <span class="kw">and</span> (<span class="va">self</span>.color <span class="op">&lt;=</span> <span class="fl">1.0</span>).<span class="bu">all</span>()</span>
<span id="cb12-361"><a href="#cb12-361"></a>            <span class="cf">for</span> x, y <span class="kw">in</span> <span class="va">self</span>.coords:</span>
<span id="cb12-362"><a href="#cb12-362"></a>                <span class="cf">assert</span> <span class="dv">0</span> <span class="op">&lt;=</span> x <span class="op">&lt;=</span> <span class="va">self</span>.x_size</span>
<span id="cb12-363"><a href="#cb12-363"></a>                <span class="cf">assert</span> <span class="dv">0</span> <span class="op">&lt;=</span> y <span class="op">&lt;=</span> <span class="va">self</span>.y_size</span>
<span id="cb12-364"><a href="#cb12-364"></a>            <span class="va">self</span>.calc_size()</span>
<span id="cb12-365"><a href="#cb12-365"></a><span class="in">```</span></span>
<span id="cb12-366"><a href="#cb12-366"></a></span>
<span id="cb12-367"><a href="#cb12-367"></a>This mutation is conceptually straight forward: </span>
<span id="cb12-368"><a href="#cb12-368"></a></span>
<span id="cb12-369"><a href="#cb12-369"></a><span class="ss">1. </span>Mutate the location of each point with <span class="in">`mutate_d`</span> as the fractional delta (i.e. 0.1 is 10% variation in position) based on the whole canvas width and height. </span>
<span id="cb12-370"><a href="#cb12-370"></a><span class="ss">2. </span>Mutate the colour of each polygon slightly. The approach is similar to the location, with <span class="in">`mutate_d`</span> indicating a fraction delta. In this case the max is 1, so taking the random output is enough here. Because our colour is RGB, we input the <span class="in">`self.color_c`</span> into random to get the desired number of channels (3). </span>
<span id="cb12-371"><a href="#cb12-371"></a></span>
<span id="cb12-372"><a href="#cb12-372"></a>To see what this looks like if we just have some polygons and keep mutating them. </span>
<span id="cb12-373"><a href="#cb12-373"></a></span>
<span id="cb12-374"><a href="#cb12-374"></a><span class="al">![Mutations of several polygons over time](images/genetic-algorithms/polygon_mutation.gif)</span>{#fig-polygon-mutation}</span>
<span id="cb12-375"><a href="#cb12-375"></a></span>
<span id="cb12-376"><a href="#cb12-376"></a><span class="fu">### Penalty</span></span>
<span id="cb12-377"><a href="#cb12-377"></a></span>
<span id="cb12-378"><a href="#cb12-378"></a>Because we do not want a model that just keeps adding polygons, we will penalize based on the number of polygons. The problem here is that you do not want to penalize it too much. If the difference of the penalty of one extra polygon is greater than the average difference in fitness between different individuals, then just removing a polygon will almost always be the best option. This happened at numerous attempts, and you just end up with an empty white grid very fast.</span>
<span id="cb12-379"><a href="#cb12-379"></a></span>
<span id="cb12-380"><a href="#cb12-380"></a>The penalty was calculated as follows: $p = 1 + \lvert pop\rvert * r_{pen}$ where $p$ is the eventual penalty, $\lvert pop\rvert$ is the total population size and $r_{pen}$ is the penalty rate. The penalty is applied as multiplier to the loss, which is the same as before: MSE. Hence the computation becomes $L_{pen} = L * p$ where $L$ and $L_{pen}$ indicate the loss initially and penalized, respectively.</span>
<span id="cb12-381"><a href="#cb12-381"></a></span>
<span id="cb12-382"><a href="#cb12-382"></a><span class="fu">### Population crossover</span></span>
<span id="cb12-383"><a href="#cb12-383"></a></span>
<span id="cb12-384"><a href="#cb12-384"></a>The last interesting section is how to achieve the population crossover here. </span>
<span id="cb12-385"><a href="#cb12-385"></a></span>
<span id="cb12-386"><a href="#cb12-386"></a></span>
<span id="cb12-389"><a href="#cb12-389"></a><span class="in">```{python}</span></span>
<span id="cb12-390"><a href="#cb12-390"></a><span class="co">#| column: page</span></span>
<span id="cb12-391"><a href="#cb12-391"></a><span class="co">#| eval: false</span></span>
<span id="cb12-392"><a href="#cb12-392"></a></span>
<span id="cb12-393"><a href="#cb12-393"></a>    <span class="kw">def</span> combine(<span class="va">self</span>):</span>
<span id="cb12-394"><a href="#cb12-394"></a>        pairs <span class="op">=</span> <span class="bu">list</span>(permutations(<span class="va">self</span>.pop, r<span class="op">=</span><span class="dv">2</span>))</span>
<span id="cb12-395"><a href="#cb12-395"></a>        sample_pairs <span class="op">=</span> random.choices(pairs, k<span class="op">=</span><span class="va">self</span>.popsize)  <span class="co"># Sample popsize pairs out of all combinations. N out of N*(N-1)</span></span>
<span id="cb12-396"><a href="#cb12-396"></a></span>
<span id="cb12-397"><a href="#cb12-397"></a>        <span class="co"># sample all permutations in the sample_top_n percent of the population.</span></span>
<span id="cb12-398"><a href="#cb12-398"></a>        sample_pairs <span class="op">+=</span> <span class="bu">list</span>(</span>
<span id="cb12-399"><a href="#cb12-399"></a>            permutations(<span class="va">self</span>.pop[: <span class="bu">int</span>(<span class="bu">len</span>(<span class="va">self</span>.pop) <span class="op">*</span> <span class="va">self</span>.sample_top_n)], r<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb12-400"><a href="#cb12-400"></a>        )</span>
<span id="cb12-401"><a href="#cb12-401"></a></span>
<span id="cb12-402"><a href="#cb12-402"></a>        <span class="co"># Create copies of the copy_top_perc fraction of the population</span></span>
<span id="cb12-403"><a href="#cb12-403"></a>        children <span class="op">=</span> [</span>
<span id="cb12-404"><a href="#cb12-404"></a>            <span class="va">self</span>.get_best().copy() <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">max</span>(<span class="bu">int</span>(<span class="va">self</span>.copy_top_perc <span class="op">*</span> <span class="bu">len</span>(<span class="va">self</span>.pop)), <span class="dv">2</span>))</span>
<span id="cb12-405"><a href="#cb12-405"></a>        ]</span>
<span id="cb12-406"><a href="#cb12-406"></a></span>
<span id="cb12-407"><a href="#cb12-407"></a>        <span class="co"># Add crossover of the picked pairs and add to the children.</span></span>
<span id="cb12-408"><a href="#cb12-408"></a>        children <span class="op">+=</span> [x.crossover(y) <span class="cf">for</span> (x, y) <span class="kw">in</span> sample_pairs]</span>
<span id="cb12-409"><a href="#cb12-409"></a>        <span class="va">self</span>.pop <span class="op">+=</span> children</span>
<span id="cb12-410"><a href="#cb12-410"></a><span class="in">```</span></span>
<span id="cb12-411"><a href="#cb12-411"></a></span>
<span id="cb12-412"><a href="#cb12-412"></a>As stated before, we want to have a good balance between selecting fit individuals but also retaining the variance of the whole population. I try to find a balance in this by both selecting from the total population while also sampling the top <span class="in">`x`</span> percent more than the rest and even copying the top <span class="in">`y`</span> percent. </span>
<span id="cb12-413"><a href="#cb12-413"></a></span>
<span id="cb12-414"><a href="#cb12-414"></a><span class="fu">### Results</span></span>
<span id="cb12-415"><a href="#cb12-415"></a></span>
<span id="cb12-416"><a href="#cb12-416"></a><span class="fu">#### Polygon Fox</span></span>
<span id="cb12-417"><a href="#cb12-417"></a></span>
<span id="cb12-418"><a href="#cb12-418"></a>Since we are playing with polygons, I decided a target that was made of polygons might be suitable. This fox has some clear advantages for polygons, with big blue areas and a pointy bright fox head in the middle. </span>
<span id="cb12-419"><a href="#cb12-419"></a></span>
<span id="cb12-420"><a href="#cb12-420"></a><span class="al">![Best individual using polygon approach, target and two loss metrics of a fox image](images/genetic-algorithms/fox_training_optimized.gif)</span>{#fig-polygon-fox .column-screen}</span>
<span id="cb12-421"><a href="#cb12-421"></a></span>
<span id="cb12-422"><a href="#cb12-422"></a>We observe a sharp incline in the number of polygons, even though it does not really seem to result in a clear improvement in fit. It seems the penalty was not tuned appropriate for this case. In this middle, we do see the fox head shape become apparant, but the algorithm fails to fill in the finer details of the head. </span>
<span id="cb12-423"><a href="#cb12-423"></a></span>
<span id="cb12-424"><a href="#cb12-424"></a><span class="fu">#### Rick &amp; Morty</span></span>
<span id="cb12-425"><a href="#cb12-425"></a></span>
<span id="cb12-426"><a href="#cb12-426"></a><span class="al">![Best individual using polygon approach, target and two loss metrics of a rick and morty image](images/genetic-algorithms/rick_polygon_optimized.gif)</span>{#fig-polygon-rick .column-screen}</span>
<span id="cb12-427"><a href="#cb12-427"></a></span>
<span id="cb12-428"><a href="#cb12-428"></a>It's clear that this image has too much detail for this algorithms. Many of the planes are too small to easily get picked up by the mean-square-error reduction. The best fit is often achieved by having big polygons match up with the background. Additionally, the meandering of the number of polygons is a clear indication that the penalty was nicely balanced, since there was no clear preference. </span>
<span id="cb12-429"><a href="#cb12-429"></a></span>
<span id="cb12-430"><a href="#cb12-430"></a></span>
<span id="cb12-431"><a href="#cb12-431"></a><span class="fu">#### Hyper parameter grid search</span></span>
<span id="cb12-432"><a href="#cb12-432"></a></span>
<span id="cb12-435"><a href="#cb12-435"></a><span class="in">```{python}</span></span>
<span id="cb12-436"><a href="#cb12-436"></a><span class="co">#| echo: false</span></span>
<span id="cb12-437"><a href="#cb12-437"></a></span>
<span id="cb12-438"><a href="#cb12-438"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb12-439"><a href="#cb12-439"></a><span class="im">import</span> plotly.express <span class="im">as</span> px</span>
<span id="cb12-440"><a href="#cb12-440"></a><span class="im">import</span> warnings</span>
<span id="cb12-441"><a href="#cb12-441"></a>warnings.simplefilter(action<span class="op">=</span><span class="st">'ignore'</span>, category<span class="op">=</span><span class="pp">FutureWarning</span>)</span>
<span id="cb12-442"><a href="#cb12-442"></a></span>
<span id="cb12-443"><a href="#cb12-443"></a>results_df <span class="op">=</span> pd.read_parquet(<span class="st">'images/genetic-algorithms/grid_search_results_650it_polygons.parquet'</span>)</span>
<span id="cb12-444"><a href="#cb12-444"></a>px.parallel_coordinates(results_df, color<span class="op">=</span><span class="st">'fitness'</span>, labels<span class="op">=</span>results_df.columns)</span>
<span id="cb12-445"><a href="#cb12-445"></a><span class="in">```</span></span>
<span id="cb12-446"><a href="#cb12-446"></a></span>
<span id="cb12-447"><a href="#cb12-447"></a>To verify some results, I ran a hyper parameter search. I fixed the mutation probability and delta for this experiment, but in hindsight I should run it to include those. </span>
<span id="cb12-448"><a href="#cb12-448"></a></span>
<span id="cb12-449"><a href="#cb12-449"></a>From the figure, if you select only the lowest losses, it becomes clear that most of the hyper parameters do not significantly impact the outcome. Going down, we first see that the addition/deletion probability starts to fade, with only the fewer values returning low losses. After that, the <span class="in">`sample_top_n`</span>=0 is dropped, meaning that some sampling of the top candidates does improve results.   </span>
<span id="cb12-450"><a href="#cb12-450"></a></span>
<span id="cb12-451"><a href="#cb12-451"></a>It is interesting to see that the number of polygons doesn't seem to have a big impact, and it's strange to see <span class="in">`copy_top_perc`</span> not have much impact while the <span class="in">`sample_top_n`</span> does. They should represent some level of similarity in their results. </span>
<span id="cb12-452"><a href="#cb12-452"></a></span>
<span id="cb12-453"><a href="#cb12-453"></a><span class="fu">### Future improvements</span></span>
<span id="cb12-454"><a href="#cb12-454"></a></span>
<span id="cb12-455"><a href="#cb12-455"></a>For the pixel approach, a more balanced approach between crossover and mutation seems appropriate. It's clear the algorithm quickly descents to a point where only mutations seems to be carrying improvements. Tuning the ratios to have a healthier balance with crossover would hopefully result in a slower but longer and more persistent decline of the loss. </span>
<span id="cb12-456"><a href="#cb12-456"></a></span>
<span id="cb12-457"><a href="#cb12-457"></a></span>
<span id="cb12-458"><a href="#cb12-458"></a>For the polygon approach, I think one possible improvement is to have polygons that work on different scales. This means that we would have some polygons that work on large areas and other on small areas and we restrict the number in both or fix them to some proportion. That might allow the algorithm to fill in some finer details while also filling the big areas. </span>
<span id="cb12-459"><a href="#cb12-459"></a></span>
<span id="cb12-460"><a href="#cb12-460"></a>Additionally, the same improvement for the polygons might have to be made as for the pixels. The polygons also quickly seemed to descent into a situation where all individuals are very similar, hence more and stickier crossing over would be good. </span>
<span id="cb12-461"><a href="#cb12-461"></a></span>
<span id="cb12-462"><a href="#cb12-462"></a>Lastly, functionality that allows the addition and deletion of polygon points might bring an interesting variation. This could support pentagons, hexagons and more. </span>
<span id="cb12-463"><a href="#cb12-463"></a></span>
<span id="cb12-464"><a href="#cb12-464"></a></span>
<span id="cb12-465"><a href="#cb12-465"></a><span class="fu">## Conclusion</span></span>
<span id="cb12-466"><a href="#cb12-466"></a></span>
<span id="cb12-467"><a href="#cb12-467"></a>In this post I showed two approaches that can replicate an image given some target using genetic algorithms. Both approaches have some advantages and some drawbacks, but both have their use. While this example is mainly for academic purposes, the core genetic algorithm has many applications and this practice both improves understanding and awareness of it. </span>
<span id="cb12-468"><a href="#cb12-468"></a></span>
<span id="cb12-469"><a href="#cb12-469"></a>Personally, I've really enjoyed working on this project with both the academic understanding as well as the engineering of it being sometimes challenging. I hope you, the reader, has learned something from this post and can use it in your own work. </span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->



</body></html>